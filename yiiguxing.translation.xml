<application>
  <component name="AppStorage">
    <option name="newTranslationDialogWidth" value="598" />
    <option name="newTranslationDialogX" value="623" />
    <option name="newTranslationDialogY" value="342" />
    <option name="pinTranslationDialog" value="true" />
    <histories>
      <item value="Catalina" />
      <item value="catalina" />
      <item value="numerTemp -&gt; contractReview -&gt; reportManage" />
      <item value="James House" />
      <item value="Trigger Fired Bundle" />
      <item value="notify Scheduler Thread" />
      <item value="pause Job" />
      <item value="Quartz Disallow Concurrent Execution" />
      <item value="Quartz Job Execution" />
      <item value="RUNTIME" />
      <item value="Soap Fault Exception" />
      <item value="Juergen Hoeller" />
      <item value="DEFAULT EXCLUSION FILTER" />
      <item value="collect Imports" />
      <item value="cates one or more &lt;em&gt;component classes&lt;em&gt; to import &amp;mdash; typically {@link Configuration @Configuration} classes. &lt;p&gt;Provides functionality equivalent to the {@code &lt;import&gt;} element in Spring XML. Allows for importing {@code @Configuration} classes, {@link ImportSelector} and {@link ImportBeanDefinitionRegistrar} implementations, as well as regular component classes (as of 4.2; analogous to {@link AnnotationConfigApplicationContextregister}). &lt;p&gt;{@code @Bean} definitions declared in imported {@code @Configuration} classes should be accessed by using {@link org.springframework.beans.factory.annotation.Autowired @Autowired} injection. Either the bean itself can be autowired, or the configuration class instance declaring the bean can be autowired. The latter approach allows for explicit, IDE-friendly navigation between {@code @Configuration} class methods. &lt;p&gt;May be declared at the class level or as a meta-annotation. &lt;p&gt;If XML or other non-{@code @Configuration} bean definition resources need to be imported, use the {@link ImportResource @ImportResource} annotation instead." />
      <item value="Scheduling Configuration" />
      <item value="get Contract Number Prefix" />
      <item value="data Prefix" />
      <item value="Enable Scheduling" />
      <item value="Business System Handler Schedule Task" />
      <item value="所以两次调用一般第一次返回true" />
      <item value="并不会重置中断标记状态" />
      <item value="并且会重置此线程的终端标记" />
      <item value="但是是否中断了还是取决于线程本身" />
      <item value="标记当前线程为中断状态" />
      <item value="返回当前线程是否已经中断的标志位" />
      <item value="返回当前线程中断的标志位" />
      <item value="interrupt" />
      <item value="transient" />
      <item value="Josh Bloch" />
      <item value="Josh Bloch (Added exception chaining and programmatic access to stack trace in 1.4.)" />
      <item value="Frank Yellin" />
      <item value="see" />
      <item value="See Also" />
      <item value="Inserts the specified element into the queue represented by this deque (in other words, at the tail of this deque) if it is possible to do so immediately without violating capacity restrictions, returning {@code true} upon success and {@code false} if no space is currently available. When using a capacity-restricted deque, this method is generally preferable to the {@link add} method, which can fail to insert an element only by throwing an exception. &lt;p&gt;This method is equivalent to {@link offerLast}." />
      <item value="This class provides a skeletal implementation of the &lt;tt&gt;List&lt;tt&gt; interface to minimize the effort required to implement this interface backed by a &quot;sequential access&quot; data store (such as a linked list). For random access data (such as an array), &lt;tt&gt;AbstractList&lt;tt&gt; should be used in preference to this class.&lt;p&gt; This class is the opposite of the &lt;tt&gt;AbstractList&lt;tt&gt; class in the sense that it implements the &quot;random access&quot; methods (&lt;tt&gt;get(int index)&lt;tt&gt;, &lt;tt&gt;set(int index, E element)&lt;tt&gt;, &lt;tt&gt;add(int index, E element)&lt;tt&gt; and &lt;tt&gt;remove(int index)&lt;tt&gt;) on top of the list's list iterator, instead of the other way around.&lt;p&gt; To implement a list the programmer needs only to extend this class and provide implementations for the &lt;tt&gt;listIterator&lt;tt&gt; and &lt;tt&gt;size&lt;tt&gt; methods. For an unmodifiable list, the programmer need only implement the list iterator's &lt;tt&gt;hasNext&lt;tt&gt;, &lt;tt&gt;next&lt;tt&gt;, &lt;tt&gt;hasPrevious&lt;tt&gt;, &lt;tt&gt;previous&lt;tt&gt; and &lt;tt&gt;index&lt;tt&gt; methods.&lt;p&gt; For a modifiable list the programmer should additionally implement the list iterator's &lt;tt&gt;set&lt;tt&gt; method. For a variable-size list the programmer should additionally implement the list iterator's &lt;tt&gt;remove&lt;tt&gt; and &lt;tt&gt;add&lt;tt&gt; methods.&lt;p&gt; The programmer should generally provide a void (no argument) and collection constructor, as per the recommendation in the &lt;tt&gt;Collection&lt;tt&gt; interface specification.&lt;p&gt; This class is a member of the &lt;a href=&quot;{@docRoot}..technotesguidescollectionsindex.html&quot;&gt; Java Collections Framework&lt;a&gt;." />
      <item value="Abstract Sequential List" />
      <item value="offer" />
      <item value="Inserts the specified element into this queue, waiting up to the specified wait time if necessary for space to become available." />
      <item value="3当前线程中断状态" />
      <item value="thread Sleep" />
      <item value="start" />
      <item value="interrupted" />
      <item value="Computes a result, or throws an exception if unable to do so. @return computed result @throws Exception if unable to compute a result" />
      <item value="Functional Interface" />
      <item value="p&gt;However, the compiler will treat any interface meeting the definition of a functional interface as a functional interface regardless of whether or not a {@code FunctionalInterface} annotation is present on the interface declaration." />
      <item value="An informative annotation type used to indicate that an interface type declaration is intended to be a &lt;i&gt;functional interface&lt;i&gt; as defined by the Java Language Specification. Conceptually, a functional interface has exactly one abstract method. Since {@linkplain java.lang.reflect.MethodisDefault() default methods} have an implementation, they are not abstract. If an interface declares an abstract method overriding one of the public methods of {@code java.lang.Object}, that also does &lt;em&gt;not&lt;em&gt; count toward the interface's abstract method count since any implementation of the interface will have an implementation from {@code java.lang.Object} or elsewhere. &lt;p&gt;Note that instances of functional interfaces can be created with lambda expressions, method references, or constructor references. &lt;p&gt;If a type is annotated with this annotation type, compilers are required to generate an error message unless: &lt;ul&gt; &lt;li&gt; The type is an interface type and not an annotation type, enum, or class. &lt;li&gt; The annotated type satisfies the requirements of a functional interface. &lt;ul&gt; &lt;p&gt;However, the compiler will treat any interface meeting the definition of a functional interface as a functional interface regardless of whether or not a {@code FunctionalInterface} annotation is present on the interface declaration." />
      <item value="Interface Method Body" />
      <item value="form Save" />
      <item value="Req Cont Review" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="3746" />
        <entry key="ENGLISH" value="3747" />
        <entry key="ALBANIAN" value="3" />
        <entry key="ARABIC" value="3" />
        <entry key="IRISH" value="1" />
        <entry key="ICELANDIC" value="3" />
        <entry key="AFRIKAANS" value="2" />
        <entry key="DANISH" value="2" />
        <entry key="GERMAN" value="2" />
        <entry key="FRENCH" value="2" />
        <entry key="FILIPINO" value="2" />
        <entry key="HAITIAN_CREOLE" value="2" />
        <entry key="DUTCH" value="2" />
        <entry key="CATALAN" value="2" />
        <entry key="KANNADA" value="1" />
        <entry key="LATIN" value="11" />
        <entry key="LATVIAN" value="1" />
        <entry key="LUXEMBOURGISH" value="3" />
        <entry key="ROMANIAN" value="5" />
        <entry key="MALAGASY" value="1" />
        <entry key="MALTESE" value="2" />
        <entry key="MAORI" value="1" />
        <entry key="HMONG" value="1" />
        <entry key="NORWEGIAN" value="3" />
        <entry key="PORTUGUESE" value="7" />
        <entry key="JAPANESE" value="1" />
        <entry key="SWEDISH" value="2" />
        <entry key="SLOVENIAN" value="1" />
        <entry key="WELSH" value="2" />
        <entry key="UZBEK" value="2" />
        <entry key="SPANISH" value="6" />
        <entry key="HAWAIIAN" value="2" />
        <entry key="HUNGARIAN" value="1" />
        <entry key="ITALIAN" value="6" />
        <entry key="HINDI" value="4" />
        <entry key="INDONESIAN" value="4" />
        <entry key="JAVANESE" value="1" />
        <entry key="YORUBA" value="1" />
        <entry key="VIETNAMESE" value="4" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1659860808522" />
  </component>
</application>
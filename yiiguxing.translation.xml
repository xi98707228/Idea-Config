<application>
  <component name="AppStorage">
    <option name="newTranslationDialogWidth" value="598" />
    <option name="newTranslationDialogX" value="623" />
    <option name="newTranslationDialogY" value="342" />
    <option name="pinTranslationDialog" value="true" />
    <histories>
      <item value="step 01 Comparable Student Beans" />
      <item value="Uni Relay" />
      <item value="Asynchronous Completion Task" />
      <item value="Completion" />
      <item value="The argument supplied to the current call to java.util.concurrent.locks.LockSupport.park. Set by (private) java.util.concurrent.locks.LockSupport.setBlocker Accessed using java.util.concurrent.locks.LockSupport.getBlocker" />
      <item value="park Nanos" />
      <item value="A {@link Future} that may be explicitly completed (setting its value and status), and may be used as a {@link CompletionStage}, supporting dependent functions and actions that trigger upon its completion. &lt;p&gt;When two or more threads attempt to {@link complete complete}, {@link completeExceptionally completeExceptionally}, or {@link cancel cancel} a CompletableFuture, only one of them succeeds. &lt;p&gt;In addition to these and related methods for directly manipulating status and results, CompletableFuture implements interface {@link CompletionStage} with the following policies: &lt;ul&gt; &lt;li&gt;Actions supplied for dependent completions of &lt;em&gt;non-async&lt;em&gt; methods may be performed by the thread that completes the current CompletableFuture, or by any other caller of a completion method.&lt;li&gt; &lt;li&gt;All &lt;em&gt;async&lt;em&gt; methods without an explicit Executor argument are performed using the {@link ForkJoinPoolcommonPool()} (unless it does not support a parallelism level of at least two, in which case, a new Thread is created to run each task). To simplify monitoring, debugging, and tracking, all generated asynchronous tasks are instances of the marker interface {@link AsynchronousCompletionTask}. &lt;li&gt; &lt;li&gt;All CompletionStage methods are implemented independently of other public methods, so the behavior of one method is not impacted by overrides of others in subclasses. &lt;li&gt; &lt;ul&gt; &lt;p&gt;CompletableFuture also implements {@link Future} with the following policies: &lt;ul&gt; &lt;li&gt;Since (unlike {@link FutureTask}) this class has no direct control over the computation that causes it to be completed, cancellation is treated as just another form of exceptional completion. Method {@link cancel cancel} has the same effect as {@code completeExceptionally(new CancellationException())}. Method {@link isCompletedExceptionally} can be used to determine if a CompletableFuture completed in any exceptional fashion.&lt;li&gt; &lt;li&gt;In case of exceptional completion with a CompletionException, methods {@link get()} and {@link get(long, TimeUnit)} throw an {@link ExecutionException} with the same cause as held in the corresponding CompletionException. To simplify usage in most contexts, this class also defines methods {@link join()} and {@link getNow} that instead throw the CompletionException directly in these cases.&lt;li&gt; &lt;ul&gt;" />
      <item value="Thread Per Task Executor" />
      <item value="Mark Reinhold" />
      <item value="Read a byte from each page to bring it into memory. A checksum is computed as we go along to prevent the compiler from otherwise considering the loop as dead code." />
      <item value="register Methods To Filter" />
      <item value="array Index Scale" />
      <item value="register Natives" />
      <item value="Completable Future" />
      <item value="Locale" />
      <item value="compute If Present" />
      <item value="put If Absent" />
      <item value="full Fence" />
      <item value="Check Map.Entry[].class since it's the nearest public type to what we're actually creating." />
      <item value="internal Write Entries" />
      <item value="after Node Access" />
      <item value="Callbacks to allow LinkedHashMap post-actions" />
      <item value="after Node Insertion" />
      <item value="public" />
      <item value="Thread Pool Executor" />
      <item value="java" />
      <item value="Compute smallest power of 2 &gt; minCapacity" />
      <item value="ensure Capacity" />
      <item value="Gallop left until a[b+hint - ofs] &lt;= key &lt; a[b+hint - lastOfs]" />
      <item value="gallop Right" />
      <item value="Josh Bloch" />
      <item value="This is a near duplicate of {@link TimSort}, modified for use with arrays of objects that implement {@link Comparable}, instead of using explicit comparators." />
      <item value="The invariants still hold: pivot &gt;= all in [lo, left) and pivot &lt; all in [left, start), so pivot belongs at left. Note that if there are elements equal to pivot, left points to the first slot after them -- that's why this sort is stable. Slide elements over to make room for pivot." />
      <item value="binary Sort" />
      <item value="This is a near duplicate of {@link TimSort}, modified for use with arrays of objects that implement {@link Comparable}, instead of using explicit comparators. &lt;p&gt;If you are using an optimizing VM, you may find that ComparableTimSort offers no performance benefit over TimSort in conjunction with a comparator that simply returns {@code ((Comparable)first).compareTo(Second)}. If this is the case, you are better off deleting ComparableTimSort to eliminate the code duplication. (See Arrays.java for details.)" />
      <item value="Comparable Tim Sort" />
      <item value="QUICKSORT THRESHOLD" />
      <item value="Index run[i] is the start of i-th run (ascending or descending sequence)." />
      <item value="Use Quicksort on small arrays" />
      <item value="middle" />
      <item value="middle Value" />
      <item value="Move negative zeros to the beginning of the sub-range." />
      <item value="This class implements the Dual-Pivot Quicksort algorithm by Vladimir Yaroslavskiy, Jon Bentley, and Josh Bloch. The algorithm offers O(n log(n)) performance on many data sets that cause other quicksorts to degrade to quadratic performance, and is typically faster than traditional (one-pivot) Quicksort implementations. All exposed methods are package-private, designed to be invoked from public methods (in class Arrays) after performing any necessary array bounds checks and expanding parameters into the required forms." />
      <item value="quartiles" />
      <item value="Relay" />
      <item value="Dual Pivot Quicksort" />
      <item value="parallel Sort" />
      <item value="primitive" />
      <item value="Visitable" />
      <item value="V Paper" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="6370" />
        <entry key="ENGLISH" value="6371" />
        <entry key="ALBANIAN" value="3" />
        <entry key="ARABIC" value="3" />
        <entry key="IRISH" value="2" />
        <entry key="BULGARIAN" value="1" />
        <entry key="ICELANDIC" value="3" />
        <entry key="AFRIKAANS" value="3" />
        <entry key="DANISH" value="17" />
        <entry key="GERMAN" value="4" />
        <entry key="FRENCH" value="2" />
        <entry key="FILIPINO" value="2" />
        <entry key="FRISIAN" value="1" />
        <entry key="HAITIAN_CREOLE" value="2" />
        <entry key="DUTCH" value="3" />
        <entry key="CATALAN" value="2" />
        <entry key="KANNADA" value="2" />
        <entry key="LATIN" value="18" />
        <entry key="LATVIAN" value="1" />
        <entry key="LITHUANIAN" value="1" />
        <entry key="LUXEMBOURGISH" value="4" />
        <entry key="ROMANIAN" value="5" />
        <entry key="MALAGASY" value="4" />
        <entry key="MALTESE" value="4" />
        <entry key="MARATHI" value="1" />
        <entry key="MAORI" value="1" />
        <entry key="HMONG" value="2" />
        <entry key="ZULU" value="1" />
        <entry key="NORWEGIAN" value="4" />
        <entry key="PORTUGUESE" value="11" />
        <entry key="JAPANESE" value="1" />
        <entry key="SWEDISH" value="2" />
        <entry key="SLOVAK" value="1" />
        <entry key="SLOVENIAN" value="1" />
        <entry key="WELSH" value="2" />
        <entry key="UZBEK" value="2" />
        <entry key="SPANISH" value="13" />
        <entry key="HAWAIIAN" value="2" />
        <entry key="HUNGARIAN" value="1" />
        <entry key="ITALIAN" value="11" />
        <entry key="HINDI" value="12" />
        <entry key="INDONESIAN" value="4" />
        <entry key="JAVANESE" value="1" />
        <entry key="YORUBA" value="1" />
        <entry key="VIETNAMESE" value="5" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1663681503656" />
  </component>
</application>
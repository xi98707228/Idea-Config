<application>
  <component name="AppStorage">
    <option name="newTranslationDialogWidth" value="594" />
    <option name="newTranslationDialogX" value="623" />
    <option name="newTranslationDialogY" value="342" />
    <option name="pinTranslationDialog" value="true" />
    <histories>
      <item value="the" />
      <item value="nacos" />
      <item value="Ignore" />
      <item value="field Name" />
      <item value="field Type Is Date" />
      <item value="condition Param Array" />
      <item value="config Condition Param" />
      <item value="get Id Str" />
      <item value="set Make Time" />
      <item value="config Expression Node Service" />
      <item value="json Object" />
      <item value="Doug Lea" />
      <item value="@author Doug Lea ({@code ConcurrentHashMap})" />
      <item value="Closes any resources that are held by the client. &lt;p&gt; Note that (as described in Doug Lea's discussion about interrupting IO operations in &quot;Concurrent Programming in Java&quot; (Addison-Wesley Professional, 2nd edition, 1999) this method is used to interrupt any blocked IO operation in the client when the server is shutting down. The client implementation must anticipate this potential, and gracefully exit when the blocked IO operation throws the relevant {@link IOException} subclass. &lt;p&gt; Note also, that unlike {@link Closeableclose()} this method is not permitted to propagate any {@link IOException} that occurs when closing the underlying resource(s)." />
      <item value="Note that (as described in Doug Lea's discussion about interrupting IO" />
      <item value="Scott Violet" />
      <item value="Amy Fowler" />
      <item value="Jeff Dinkins" />
      <item value="A human readable description of the file. For example, a file named &lt;i&gt;jag.jpg&lt;i&gt; might have a description that read: &quot;A JPEG image file of James Gosling's face&quot;." />
      <item value="unascribed" />
      <item value="Feature" />
      <item value="error" />
      <item value="select List COUNT" />
      <item value="row Id" />
      <item value="是否是必须值的字段" />
      <item value="日期类型是必须填写的字段" />
      <item value="remakes" />
      <item value="is Required" />
      <item value="param Index" />
      <item value="Config Expression Node" />
      <item value="为当前表达式配置的查询参数" />
      <item value="report Id" />
      <item value="接收前端传递的查询原子参数" />
      <item value="执行字段片段" />
      <item value="表达式" />
      <item value="Primary" />
      <item value="executor Sql" />
      <item value="Simple Chart Query Executor" />
      <item value="build Executor Sql" />
      <item value="set Socket Address" />
      <item value="Caller Sensitive" />
      <item value="Security Manager" />
      <item value="Josh Bloch" />
      <item value="Stack Trace Element" />
      <item value="@param obj the object on which to test lock ownership @throws NullPointerException if obj is &lt;tt&gt;null&lt;tt&gt; @return &lt;tt&gt;true&lt;tt&gt; if the current thread holds the monitor lock on the specified object. @since 1.4" />
      <item value="Returns &lt;tt&gt;true&lt;tt&gt; if and only if the current thread holds the monitor lock on the specified object. &lt;p&gt;This method is designed to allow a program to assert that the current thread already holds a specified lock: &lt;pre&gt; assert Thread.holdsLock(obj); &lt;pre&gt; @param obj the object on which to test lock ownership @throws NullPointerException if obj is &lt;tt&gt;null&lt;tt&gt; @return &lt;tt&gt;true&lt;tt&gt; if the current thread holds the monitor lock on the specified object." />
      <item value="holds Lock" />
      <item value="This class represents a Socket Address with no protocol attachment. As an abstract class, it is meant to be subclassed with a specific, protocol dependent, implementation. &lt;p&gt; It provides an immutable object used by sockets for binding, connecting, or as returned values." />
      <item value="Inet Socket Address" />
      <item value="his class represents a socket for sending and receiving datagram packets. &lt;p&gt;A datagram socket is the sending or receiving point for a packet delivery service. Each packet sent or received on a datagram socket is individually addressed and routed. Multiple packets sent from one machine to another may be routed differently, and may arrive in any order. &lt;p&gt; Where possible, a newly constructed {@code DatagramSocket} has the {@link SocketOptionsSO_BROADCAST SO_BROADCAST} socket option enabled so as to allow the transmission of broadcast datagrams. In order to receive broadcast packets a DatagramSocket should be bound to the wildcard address. In some implementations, broadcast packets may also be received when a DatagramSocket is bound to a more specific address. &lt;p&gt; Example: {@code DatagramSocket s = new DatagramSocket(null); s.bind(new InetSocketAddress(8888)); } Which is equivalent to: {@code DatagramSocket s = new DatagramSocket(8888); } Both cases will create a DatagramSocket able to receive broadcasts on UDP port 8888. @author Pavani Diwanji @see java.net.DatagramPacket @see java.nio.channels.DatagramChannel @since JDK1.0" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="5720" />
        <entry key="ENGLISH" value="5721" />
        <entry key="ALBANIAN" value="4" />
        <entry key="ARABIC" value="1" />
        <entry key="BULGARIAN" value="1" />
        <entry key="ICELANDIC" value="4" />
        <entry key="POLISH" value="1" />
        <entry key="AFRIKAANS" value="8" />
        <entry key="DANISH" value="10" />
        <entry key="GERMAN" value="13" />
        <entry key="RUSSIAN" value="4" />
        <entry key="FRENCH" value="8" />
        <entry key="FILIPINO" value="2" />
        <entry key="FINNISH" value="6" />
        <entry key="FRISIAN" value="3" />
        <entry key="HAITIAN_CREOLE" value="6" />
        <entry key="HAUSA" value="1" />
        <entry key="DUTCH" value="7" />
        <entry key="CATALAN" value="1" />
        <entry key="KURDISH" value="4" />
        <entry key="LATIN" value="10" />
        <entry key="LUXEMBOURGISH" value="1" />
        <entry key="ROMANIAN" value="7" />
        <entry key="MALTESE" value="1" />
        <entry key="MALAYALAM" value="1" />
        <entry key="BENGALI" value="1" />
        <entry key="HMONG" value="4" />
        <entry key="NORWEGIAN" value="7" />
        <entry key="PORTUGUESE" value="9" />
        <entry key="JAPANESE" value="1" />
        <entry key="SWEDISH" value="6" />
        <entry key="SAMOAN" value="5" />
        <entry key="SESOTHO" value="2" />
        <entry key="SLOVAK" value="5" />
        <entry key="SLOVENIAN" value="3" />
        <entry key="SCOTS_GAELIC" value="1" />
        <entry key="SPANISH" value="2" />
        <entry key="GREEK" value="7" />
        <entry key="ITALIAN" value="7" />
        <entry key="HINDI" value="1" />
        <entry key="INDONESIAN" value="5" />
        <entry key="JAVANESE" value="1" />
        <entry key="VIETNAMESE" value="7" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1654478029731" />
  </component>
  <component name="Settings">
    <option name="showReplacementActionInContextMenu" value="true" />
    <option name="translateDocumentation" value="true" />
  </component>
</application>
<application>
  <component name="AppStorage">
    <option name="newTranslationDialogWidth" value="594" />
    <option name="newTranslationDialogX" value="623" />
    <option name="newTranslationDialogY" value="342" />
    <histories>
      <item value="mod Count" />
      <item value="Returns a view of the portion of this list between the specified &lt;tt&gt;fromIndex&lt;tt&gt;, inclusive, and &lt;tt&gt;toIndex&lt;tt&gt;, exclusive. (If &lt;tt&gt;fromIndex&lt;tt&gt; and &lt;tt&gt;toIndex&lt;tt&gt; are equal, the returned list is empty.) The returned list is backed by this list, so non-structural changes in the returned list are reflected in this list, and vice-versa. The returned list supports all of the optional list operations supported by this list.&lt;p&gt; This method eliminates the need for explicit range operations (of the sort that commonly exist for arrays). Any operation that expects a list can be used as a range operation by passing a subList view instead of a whole list. For example, the following idiom removes a range of elements from a list: &lt;pre&gt;{@code list.subList(from, to).clear(); }&lt;pre&gt; Similar idioms may be constructed for &lt;tt&gt;indexOf&lt;tt&gt; and &lt;tt&gt;lastIndexOf&lt;tt&gt;, and all of the algorithms in the &lt;tt&gt;Collections&lt;tt&gt; class can be applied to a subList.&lt;p&gt; The semantics of the list returned by this method become undefined if the backing list (i.e., this list) is &lt;i&gt;structurally modified&lt;i&gt; in any way other than via the returned list. (Structural modifications are those that change the size of this list, or otherwise perturb it in such a fashion that iterations in progress may yield incorrect results.) @param fromIndex low endpoint (inclusive) of the subList @param toIndex high endpoint (exclusive) of the subList @return a view of the specified range within this list @throws IndexOutOfBoundsException for an illegal endpoint index value (&lt;tt&gt;fromIndex &amp;lt; 0 || toIndex &amp;gt; size || fromIndex &amp;gt; toIndex&lt;tt&gt;)" />
      <item value="Comparator" />
      <item value="987072248" />
      <item value="流程实例Id" />
      <item value="期望" />
      <item value="input Active Id" />
      <item value="check Current Active Segment Is Input Expect" />
      <item value="get Process Active Mapping" />
      <item value="lambda" />
      <item value="如果没有选择左侧的" />
      <item value="get Work Order Statistics Data" />
      <item value="start Page" />
      <item value="DEFAULT COUNT" />
      <item value="Page Helper" />
      <item value="I Engine Proc Act Inst Service" />
      <item value="protected" />
      <item value="Resource" />
      <item value="engine Proc Act Inst Service" />
      <item value="Increments modCount!!" />
      <item value="Unsupported Operation Exception" />
      <item value="Query Operations" />
      <item value="get Process Active" />
      <item value="get Process" />
      <item value="Priority" />
      <item value="RUNTIME" />
      <item value="Retention Policy" />
      <item value="Retention" />
      <item value="Target" />
      <item value="Documented" />
      <item value="Order" />
      <item value="Neither directly nor indirectly present" />
      <item value="get Annotations By Type" />
      <item value="present, and return any annotations inside the container. Container" />
      <item value="annotations may be generated at compile-time to wrap multiple" />
      <item value="annotations of the argument type." />
      <item value="Represents an annotated element of the program currently running in this VM. This interface allows annotations to be read reflectively. All annotations returned by methods in this interface are immutable and serializable. The arrays returned by methods of this interface may be modified by callers without affecting the arrays returned to other callers. &lt;p&gt;The {@link getAnnotationsByType(Class)} and {@link getDeclaredAnnotationsByType(Class)} methods support multiple annotations of the same type on an element. If the argument to either method is a repeatable annotation type (JLS 9.6), then the method will &quot;look through&quot; a container annotation (JLS 9.7), if present, and return any annotations inside the container. Container annotations may be generated at compile-time to wrap multiple annotations of the argument type. &lt;p&gt;The terms &lt;em&gt;directly present&lt;em&gt;, &lt;em&gt;indirectly present&lt;em&gt;, &lt;em&gt;present&lt;em&gt;, and &lt;em&gt;associated&lt;em&gt; are used throughout this interface to describe precisely which annotations are returned by methods: &lt;ul&gt; &lt;li&gt; An annotation &lt;i&gt;A&lt;i&gt; is &lt;em&gt;directly present&lt;em&gt; on an element &lt;i&gt;E&lt;i&gt; if &lt;i&gt;E&lt;i&gt; has a {@code RuntimeVisibleAnnotations} or {@code RuntimeVisibleParameterAnnotations} or {@code RuntimeVisibleTypeAnnotations} attribute, and the attribute contains &lt;i&gt;A&lt;i&gt;. &lt;li&gt;An annotation &lt;i&gt;A&lt;i&gt; is &lt;em&gt;indirectly present&lt;em&gt; on an element &lt;i&gt;E&lt;i&gt; if &lt;i&gt;E&lt;i&gt; has a {@code RuntimeVisibleAnnotations} or {@code RuntimeVisibleParameterAnnotations} or {@code RuntimeVisibleTypeAnnotations} attribute, and &lt;i&gt;A&lt;i&gt; 's type is repeatable, and the attribute contains exactly one annotation whose value element contains &lt;i&gt;A&lt;i&gt; and whose type is the containing annotation type of &lt;i&gt;A&lt;i&gt; 's type. &lt;li&gt;An annotation &lt;i&gt;A&lt;i&gt; is present on an element &lt;i&gt;E&lt;i&gt; if either: &lt;ul&gt; &lt;li&gt;&lt;i&gt;A&lt;i&gt; is directly present on &lt;i&gt;E&lt;i&gt;; or &lt;li&gt;No annotation of &lt;i&gt;A&lt;i&gt; 's type is directly present on &lt;i&gt;E&lt;i&gt;, and &lt;i&gt;E&lt;i&gt; is a class, and &lt;i&gt;A&lt;i&gt; 's type is inheritable, and &lt;i&gt;A&lt;i&gt; is present on the superclass of &lt;i&gt;E&lt;i&gt;. &lt;ul&gt; &lt;li&gt;An annotation &lt;i&gt;A&lt;i&gt; is &lt;em&gt;associated&lt;em&gt; with an element &lt;i&gt;E&lt;i&gt; if either: &lt;ul&gt; &lt;li&gt;&lt;i&gt;A&lt;i&gt; is directly or indirectly present on &lt;i&gt;E&lt;i&gt;; or &lt;li&gt;No annotation of &lt;i&gt;A&lt;i&gt; 's type is directly or indirectly present on &lt;i&gt;E&lt;i&gt;, and &lt;i&gt;E&lt;i&gt; is a class, and &lt;i&gt;A&lt;i&gt;'s type is inheritable, and &lt;i&gt;A&lt;i&gt; is associated with the superclass of &lt;i&gt;E&lt;i&gt;. &lt;ul&gt; &lt;ul&gt; &lt;p&gt;The table below summarizes which kind of annotation presence different methods in this interface examine. &lt;table border&gt; &lt;caption&gt;Overview of kind of presence detected by different AnnotatedElement methods&lt;caption&gt; &lt;tr&gt;&lt;th colspan=2&gt;&lt;th&gt;&lt;th colspan=4&gt;Kind of Presence&lt;th&gt; &lt;tr&gt;&lt;th colspan=2&gt;Method&lt;th&gt;&lt;th&gt;Directly Present&lt;th&gt;&lt;th&gt;Indirectly Present&lt;th&gt;&lt;th&gt;Present&lt;th&gt;&lt;th&gt;Associated&lt;th&gt; &lt;tr&gt;&lt;td align=right&gt;{@code T}&lt;td&gt;&lt;td&gt;{@link getAnnotation(Class) getAnnotation(Class&amp;lt;T&amp;gt;)} &lt;td&gt;&lt;td&gt;&lt;td&gt;&lt;td&gt;&lt;td&gt;X&lt;td&gt;&lt;td&gt;&lt;td&gt; &lt;tr&gt; &lt;tr&gt;&lt;td align=right&gt;{@code Annotation[]}&lt;td&gt;&lt;td&gt;{@link getAnnotations getAnnotations()} &lt;td&gt;&lt;td&gt;&lt;td&gt;&lt;td&gt;&lt;td&gt;X&lt;td&gt;&lt;td&gt;&lt;td&gt; &lt;tr&gt; &lt;tr&gt;&lt;td align=right&gt;{@code T[]}&lt;td&gt;&lt;td&gt;{@link getAnnotationsByType(Class) getAnnotationsByType(Class&amp;lt;T&amp;gt;)} &lt;td&gt;&lt;td&gt;&lt;td&gt;&lt;td&gt;&lt;td&gt;&lt;td&gt;&lt;td&gt;X&lt;td&gt; &lt;tr&gt; &lt;tr&gt;&lt;td align=right&gt;{@code T}&lt;td&gt;&lt;td&gt;{@link getDeclaredAnnotation(Class) getDeclaredAnnotation(Class&amp;lt;T&amp;gt;)} &lt;td&gt;X&lt;td&gt;&lt;td&gt;&lt;td&gt;&lt;td&gt;&lt;td&gt;&lt;td&gt;&lt;td&gt; &lt;tr&gt; &lt;tr&gt;&lt;td align=right&gt;{@code Annotation[]}&lt;td&gt;&lt;td&gt;{@link getDeclaredAnnotations getDeclaredAnnotations()} &lt;td&gt;X&lt;td&gt;&lt;td&gt;&lt;td&gt;&lt;td&gt;&lt;td&gt;&lt;td&gt;&lt;td&gt; &lt;tr&gt; &lt;tr&gt;&lt;td align=right&gt;{@code T[]}&lt;td&gt;&lt;td&gt;{@link getDeclaredAnnotationsByType(Class) getDeclaredAnnotationsByType(Class&amp;lt;T&amp;gt;)} &lt;td&gt;X&lt;td&gt;&lt;td&gt;X&lt;td&gt;&lt;td&gt;&lt;td&gt;&lt;td&gt;&lt;td&gt; &lt;tr&gt; &lt;table&gt; &lt;p&gt;For an invocation of {@code get[Declared]AnnotationsByType( Class &lt; T &gt;)}, the order of annotations which are directly or indirectly present on an element &lt;i&gt;E&lt;i&gt; is computed as if indirectly present annotations on &lt;i&gt;E&lt;i&gt; are directly present on &lt;i&gt;E&lt;i&gt; in place of their container annotation, in the order in which they appear in the value element of the container annotation. &lt;p&gt;There are several compatibility concerns to keep in mind if an annotation type &lt;i&gt;T&lt;i&gt; is originally &lt;em&gt;not&lt;em&gt; repeatable and later modified to be repeatable. The containing annotation type for &lt;i&gt;T&lt;i&gt; is &lt;i&gt;TC&lt;i&gt;. &lt;ul&gt; &lt;li&gt;Modifying &lt;i&gt;T&lt;i&gt; to be repeatable is source and binary compatible with existing uses of &lt;i&gt;T&lt;i&gt; and with existing uses of &lt;i&gt;TC&lt;i&gt;. That is, for source compatibility, source code with annotations of type &lt;i&gt;T&lt;i&gt; or of type &lt;i&gt;TC&lt;i&gt; will still compile. For binary compatibility, class files with annotations of type &lt;i&gt;T&lt;i&gt; or of type &lt;i&gt;TC&lt;i&gt; (or with other kinds of uses of type &lt;i&gt;T&lt;i&gt; or of type &lt;i&gt;TC&lt;i&gt;) will link against the modified version of &lt;i&gt;T&lt;i&gt; if they linked against the earlier version. (An annotation type &lt;i&gt;TC&lt;i&gt; may informally serve as an acting containing annotation type before &lt;i&gt;T&lt;i&gt; is modified to be formally repeatable. Alternatively, when &lt;i&gt;T&lt;i&gt; is made repeatable, &lt;i&gt;TC&lt;i&gt; can be introduced as a new type.) &lt;li&gt;If an annotation type &lt;i&gt;TC&lt;i&gt; is present on an element, and &lt;i&gt;T&lt;i&gt; is modified to be repeatable with &lt;i&gt;TC&lt;i&gt; as its containing annotation type then: &lt;ul&gt; &lt;li&gt;The change to &lt;i&gt;T&lt;i&gt; is behaviorally compatible with respect to the {@code get[Declared]Annotation(Class&lt;T&gt;)} (called with an argument of &lt;i&gt;T&lt;i&gt; or &lt;i&gt;TC&lt;i&gt;) and {@code get[Declared]Annotations()} methods because the results of the methods will not change due to &lt;i&gt;TC&lt;i&gt; becoming the containing annotation type for &lt;i&gt;T&lt;i&gt;. &lt;li&gt;The change to &lt;i&gt;T&lt;i&gt; changes the results of the {@code get[Declared]AnnotationsByType(Class&lt;T&gt;)} methods called with an argument of &lt;i&gt;T&lt;i&gt;, because those methods will now recognize an annotation of type &lt;i&gt;TC&lt;i&gt; as a container annotation for &lt;i&gt;T&lt;i&gt; and will &quot;look through&quot; it to expose annotations of type &lt;i&gt;T&lt;i&gt;. &lt;ul&gt; &lt;li&gt;If an annotation of type &lt;i&gt;T&lt;i&gt; is present on an element and &lt;i&gt;T&lt;i&gt; is made repeatable and more annotations of type &lt;i&gt;T&lt;i&gt; are added to the element: &lt;ul&gt; &lt;li&gt; The addition of the annotations of type &lt;i&gt;T&lt;i&gt; is both source compatible and binary compatible. &lt;li&gt;The addition of the annotations of type &lt;i&gt;T&lt;i&gt; changes the results of the {@code get[Declared]Annotation(Class&lt;T&gt;)} methods and {@code get[Declared]Annotations()} methods, because those methods will now only see a container annotation on the element and not see an annotation of type &lt;i&gt;T&lt;i&gt;. &lt;li&gt;The addition of the annotations of type &lt;i&gt;T&lt;i&gt; changes the results of the {@code get[Declared]AnnotationsByType(Class&lt;T&gt;)} methods, because their results will expose the additional annotations of type &lt;i&gt;T&lt;i&gt; whereas previously they exposed only a single annotation of type &lt;i&gt;T&lt;i&gt;. &lt;ul&gt; &lt;ul&gt; &lt;p&gt;If an annotation returned by a method in this interface contains (directly or indirectly) a {@link Class}-valued member referring to a class that is not accessible in this VM, attempting to read the class by calling the relevant Class-returning method on the returned annotation will result in a {@link TypeNotPresentException}. &lt;p&gt;Similarly, attempting to read an enum-valued member will result in a {@link EnumConstantNotPresentException} if the enum constant in the annotation is no longer present in the enum type. &lt;p&gt;If an annotation type &lt;i&gt;T&lt;i&gt; is (meta-)annotated with an {@code @Repeatable} annotation whose value element indicates a type &lt;i&gt;TC&lt;i&gt;, but &lt;i&gt;TC&lt;i&gt; does not declare a {@code value()} method with a return type of &lt;i&gt;T&lt;i&gt;{@code []}, then an exception of type {@link java.lang.annotation.AnnotationFormatError} is thrown. &lt;p&gt;Finally, attempting to read a member whose definition has evolved incompatibly will result in a {@link" />
      <item value="All subclasses should override this method" />
      <item value="Josh Bloch" />
      <item value="Root Bean Definition" />
      <item value="get Cached Object For Factory Bean" />
      <item value="Don't let calling code try to dereference the factory if the bean isn't a factory." />
      <item value="Null Bean" />
      <item value="unique Bean" />
      <item value="bean Names For Type Including Ancestors" />
      <item value="is Factory Dereference" />
      <item value="trace" />
      <item value="do Get Bean" />
      <item value="Abstract Nestable Property Accessor" />
      <item value="Juergen Hoeller" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="2072" />
        <entry key="ENGLISH" value="2073" />
        <entry key="ALBANIAN" value="2" />
        <entry key="ARABIC" value="1" />
        <entry key="BULGARIAN" value="1" />
        <entry key="ICELANDIC" value="2" />
        <entry key="POLISH" value="1" />
        <entry key="AFRIKAANS" value="2" />
        <entry key="DANISH" value="5" />
        <entry key="RUSSIAN" value="3" />
        <entry key="FRENCH" value="6" />
        <entry key="FILIPINO" value="1" />
        <entry key="FINNISH" value="5" />
        <entry key="FRISIAN" value="1" />
        <entry key="HAITIAN_CREOLE" value="1" />
        <entry key="DUTCH" value="6" />
        <entry key="LATIN" value="4" />
        <entry key="ROMANIAN" value="4" />
        <entry key="MALAYALAM" value="1" />
        <entry key="BENGALI" value="1" />
        <entry key="HMONG" value="2" />
        <entry key="NORWEGIAN" value="3" />
        <entry key="PORTUGUESE" value="4" />
        <entry key="SAMOAN" value="3" />
        <entry key="SESOTHO" value="1" />
        <entry key="SLOVAK" value="5" />
        <entry key="SLOVENIAN" value="3" />
        <entry key="SPANISH" value="1" />
        <entry key="GREEK" value="6" />
        <entry key="ITALIAN" value="2" />
        <entry key="HINDI" value="1" />
        <entry key="INDONESIAN" value="4" />
        <entry key="VIETNAMESE" value="4" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1648453619588" />
  </component>
  <component name="Settings">
    <option name="showReplacementActionInContextMenu" value="true" />
    <option name="translateDocumentation" value="true" />
  </component>
</application>
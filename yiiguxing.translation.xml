<application>
  <component name="AppStorage">
    <option name="newTranslationDialogWidth" value="598" />
    <option name="newTranslationDialogX" value="623" />
    <option name="newTranslationDialogY" value="342" />
    <option name="pinNewTranslationDialog" value="true" />
    <histories>
      <item value="tick Id" />
      <item value="TRACE" />
      <item value="Get Mapping" />
      <item value="query Tick Life Cycle" />
      <item value="The synchronization state." />
      <item value="Count Down Latch" />
      <item value="patro Pointsl Service" />
      <item value="do Create Bean" />
      <item value="A synchronizer that may be exclusively owned by a thread. This class provides a basis for creating locks and related synchronizers that may entail a notion of ownership. The {@code AbstractOwnableSynchronizer} class itself does not manage or use this information. However, subclasses and tools may use appropriately maintained values to help control and monitor access and provide diagnostics." />
      <item value="The current owner of exclusive mode synchronization." />
      <item value="Sets the thread that currently owns exclusive access. A {@code null} argument indicates that no thread owns access. This method does not otherwise impose any synchronization or {@code volatile} field accesses. @param thread the owner thread" />
      <item value="Returns the thread last set by {@code setExclusiveOwnerThread}, or {@code null} if never set. This method does not otherwise impose any synchronization or {@code volatile} field accesses. @return the owner thread" />
      <item value="updaters" />
      <item value="Setup to support compareAndSet. We need to natively implement this here: For the sake of permitting future enhancements, we cannot explicitly subclass AtomicInteger, which would be efficient and useful otherwise. So, as the lesser of evils, we natively implement using hotspot intrinsics API. And while we are at it, we do the same for other CASable fields (which could otherwise be done with atomic field updaters)." />
      <item value="CA Sable" />
      <item value="next Offset" />
      <item value="Returns a collection containing threads that may be waiting to acquire in exclusive mode. This has the same properties as {@link getQueuedThreads} except that it only returns those threads waiting due to an exclusive acquire." />
      <item value="The current owner of exclusive mode synchronization" />
      <item value="exclusive Owner Thread" />
      <item value="Abstract Ownable Synchronizer" />
      <item value="Used by Condition" />
      <item value="Used by addWaiter" />
      <item value="EXCLUSIVE" />
      <item value="acquire Queued" />
      <item value="try Acquire" />
      <item value="Abstract Queued Synchronizer" />
      <item value="Synchronization control For CountDownLatch. Uses AQS state to represent count." />
      <item value="count Down" />
      <item value="A synchronization aid that allows one or more threads to wait until a set of operations being performed in other threads completes. &lt;p&gt;A {@code CountDownLatch} is initialized with a given &lt;em&gt;count&lt;em&gt;. The {@link await await} methods block until the current count reaches zero due to invocations of the {@link countDown} method, after which all waiting threads are released and any subsequent invocations of {@link await await} return immediately. This is a one-shot phenomenon -- the count cannot be reset. If you need a version that resets the count, consider using a {@link CyclicBarrier}. &lt;p&gt;A {@code CountDownLatch} is a versatile synchronization tool and can be used for a number of purposes. A {@code CountDownLatch} initialized with a count of one serves as a simple onoff latch, or gate: all threads invoking {@link await await} wait at the gate until it is opened by a thread invoking {@link countDown}. A {@code CountDownLatch} initialized to &lt;em&gt;N&lt;em&gt; can be used to make one thread wait until &lt;em&gt;N&lt;em&gt; threads have completed some action, or some action has been completed N times. &lt;p&gt;A useful property of a {@code CountDownLatch} is that it doesn't require that threads calling {@code countDown} wait for the count to reach zero before proceeding, it simply prevents any thread from proceeding past an {@link await await} until all threads could pass. &lt;p&gt;&lt;b&gt;Sample usage:&lt;b&gt; Here is a pair of classes in which a group of worker threads use two countdown latches: &lt;ul&gt; &lt;li&gt;The first is a start signal that prevents any worker from proceeding until the driver is ready for them to proceed; &lt;li&gt;The second is a completion signal that allows the driver to wait until all workers have completed. &lt;ul&gt; &lt;pre&gt; {@code class Driver { ... void main() throws InterruptedException { CountDownLatch startSignal = new CountDownLatch(1); CountDownLatch doneSignal = new CountDownLatch(N); for (int i = 0; i &lt; N; ++i) create and start threads new Thread(new Worker(startSignal, doneSignal)).start(); doSomethingElse(); don't let run yet startSignal.countDown(); let all threads proceed doSomethingElse(); doneSignal.await(); wait for all to finish } } class Worker implements Runnable { private final CountDownLatch startSignal; private final CountDownLatch doneSignal; Worker(CountDownLatch startSignal, CountDownLatch doneSignal) { this.startSignal = startSignal; this.doneSignal = doneSignal; } public void run() { try { startSignal.await(); doWork(); doneSignal.countDown(); } catch (InterruptedException ex) {} return; } void doWork() { ... } }}&lt;pre&gt; &lt;p&gt;Another typical usage would be to divide a problem into N parts, describe each part with a Runnable that executes that portion and counts down on the latch, and queue all the Runnables to an Executor. When all sub-parts are complete, the coordinating thread will be able to pass through await. (When threads must repeatedly count down in this way, instead use a {@link CyclicBarrier}.) &lt;pre&gt; {@code class Driver2 { ... void main() throws InterruptedException { CountDownLatch doneSignal = new CountDownLatch(N); Executor e = ... for (int i = 0; i &lt; N; ++i) create and start threads e.execute(new WorkerRunnable(doneSignal, i)); doneSignal.await(); wait for all to finish } } class WorkerRunnable implements Runnable { private final CountDownLatch doneSignal; private final int i; WorkerRunnable(CountDownLatch doneSignal, int i) { this.doneSignal = doneSignal; this.i = i; } public void run() { try { doWork(i); doneSignal.countDown(); } catch (InterruptedException ex) {} return; } void doWork() { ... } }}&lt;pre&gt; &lt;p&gt;Memory consistency effects: Until the count reaches zero, actions in a thread prior to calling {@code countDown()} &lt;a href=&quot;package-summary.htmlMemoryVisibility&quot;&gt;&lt;i&gt;happen-before&lt;i&gt;&lt;a&gt; actions following a successful return from a corresponding {@code await()} in another thread." />
      <item value="ae 812 f 13 db 0 e config" />
      <item value="Pjws Store Ws Tick" />
      <item value="get Book Row Id" />
      <item value="tick Code" />
      <item value="get Create Time" />
      <item value="Nacos Property Source Builder" />
      <item value="load Nacos Data" />
      <item value="configuration" />
      <item value="并修改其内容" />
      <item value="Ajax Result" />
      <item value="custom Contract Relation Service" />
      <item value="success" />
      <item value="get Tree Select By Dept Id" />
      <item value="relation Project Contract File List" />
      <item value="获取所有的已关联合同信息" />
      <item value="QUOTATION CONTRACT" />
      <item value="Validator" />
      <item value="Hibernate" />
      <item value="appropriate" />
      <item value="clear References Jdbc" />
      <item value="start Internal" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="739" />
        <entry key="ENGLISH" value="740" />
        <entry key="AFRIKAANS" value="1" />
        <entry key="DANISH" value="3" />
        <entry key="FRENCH" value="4" />
        <entry key="FILIPINO" value="1" />
        <entry key="FINNISH" value="4" />
        <entry key="FRISIAN" value="1" />
        <entry key="DUTCH" value="3" />
        <entry key="LATIN" value="3" />
        <entry key="ROMANIAN" value="1" />
        <entry key="BENGALI" value="1" />
        <entry key="NORWEGIAN" value="1" />
        <entry key="PORTUGUESE" value="2" />
        <entry key="SAMOAN" value="2" />
        <entry key="SLOVAK" value="4" />
        <entry key="SLOVENIAN" value="1" />
        <entry key="GREEK" value="1" />
        <entry key="ITALIAN" value="2" />
        <entry key="INDONESIAN" value="1" />
        <entry key="VIETNAMESE" value="4" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1644801773453" />
  </component>
  <component name="Settings">
    <option name="showReplacementActionInContextMenu" value="true" />
    <option name="translateDocumentation" value="true" />
  </component>
</application>
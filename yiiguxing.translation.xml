<application>
  <component name="AppStorage">
    <option name="newTranslationDialogWidth" value="598" />
    <option name="newTranslationDialogX" value="623" />
    <option name="newTranslationDialogY" value="342" />
    <histories>
      <item value="Chart Helper Service Impl" />
      <item value="chart Field Config Service" />
      <item value="target Class" />
      <item value="source Class" />
      <item value="source Bean" />
      <item value="equals" />
      <item value="get Name" />
      <item value="unregister M Bean" />
      <item value="The semantics of preDeregister are tricky. If it throws an exception, then the unregisterMBean fails. This allows an MBean to refuse to be unregistered. If it returns successfully, then the unregisterMBean can proceed. In this case the preDeregister may have cleaned up some state, and will not expect to be called a second time. So if two threads try to unregister the same MBean at the same time then one of them must wait for the other one to either (a) call preDeregister and get an exception or (b) call preDeregister successfully and unregister the MBean. Suppose thread T1 is unregistering an MBean and thread T2 is trying to unregister the same MBean, so waiting for T1. Then a deadlock is possible if the preDeregister for T1 ends up needing a lock held by T2. Given the semantics just described, there does not seem to be any way to avoid this. This will not happen to code where it is clear for any given MBean what thread may unregister that MBean. On the other hand we clearly do not want a thread that is unregistering MBean A to have to wait for another thread that is unregistering another MBean B (see bug 6318664). A deadlock in this situation could reasonably be considered gratuitous. So holding a global lock across the preDeregister call would be bad. So we have a set of ObjectNames that some thread is currently unregistering. When a thread wants to unregister a name, it must first check if the name is in the set, and if so it must wait. When a thread successfully unregisters a name it removes the name from the set and notifies any waiting threads that the set has changed. This implies that we must be very careful to ensure that the name is removed from the set and waiters notified, no matter what code path is taken" />
      <item value="The semantics of preDeregister are tricky. If it throws an exception, then the unregisterMBean fails. This allows an MBean to refuse to be unregistered. If it returns successfully, then the unregisterMBean can proceed. In this case the preDeregister may have cleaned up some state, and will not expect to be called a second time. So if two threads try to unregister the same MBean at the same time then one of them must wait for the other one to either (a) call preDeregister and get an exception or (b) call preDeregister successfully and unregister the MBean. Suppose thread T1 is unregistering an MBean and thread T2 is trying to unregister the same MBean, so waiting for T1. Then a deadlock is possible if the preDeregister for T1 ends up needing a lock held by T2. Given the semantics just described, there does not seem to be any way to avoid this. This will not happen to code where it is clear for any given MBean what thread may unregister that MBean. On the other hand we clearly do not want a thread that is unregistering MBean A to have to wait for another thread that is unregistering another MBean B (see bug 6318664). A deadlock in this situation could reasonably be considered gratuitous. So holding a global lock across the preDeregister call would be bad. So we have a set of ObjectNames that some thread is currently unregistering. When a thread wants to unregister a name, it must first check if the name is in the set, and if so it must wait. When a thread successfully unregisters a name it removes the name from the set and notifies any waiting threads that the set has changed. This implies that we must be very careful to ensure that the name is removed from the set and waiters notified, no matter what code path is taken." />
      <item value="M Bean Server" />
      <item value="M Bean Server Connection" />
      <item value="Default M Bean Server Interceptor" />
      <item value="Bean Scope Convert" />
      <item value="Objects" />
      <item value="convert Bean Property Skip Null" />
      <item value="Bean Convert" />
      <item value="Chart Field Condition Dto" />
      <item value="To String Style" />
      <item value="target Bean" />
      <item value="FutureTask extension to enqueue upon completion" />
      <item value="Queueing Future" />
      <item value="For efficiency, especially in executors with limited parallelism, check to see if previously submitted tasks are done before submitting more of them. This interleaving plus the exception mechanics account for messiness of main loop." />
      <item value="assert" />
      <item value="Chart Horizontal Axis Dto" />
      <item value="field Config Key" />
      <item value="Ajax Result" />
      <item value="Chart Config Helper" />
      <item value="987072248" />
      <item value="主要目的就是获取图表的一些关联数据信息" />
      <item value="助手" />
      <item value="chart" />
      <item value="private" />
      <item value="Bootstrap loader for Catalina. This application constructs a class loader for use in loading the Catalina internal classes (by accumulating all of the JAR files found in the &quot;server&quot; directory under &quot;catalina.home&quot;), and starts the regular execution of the container. The purpose of this roundabout approach is to keep the Catalina internal classes (and any other classes they depend on, such as an XML parser) out of the system class path and therefore not visible to application level classes." />
      <item value="daemon" />
      <item value="Bootstrap" />
      <item value="Single Sign On Entry" />
      <item value="Chart Field Condition Config Service" />
      <item value="Chart Field Condition Controller" />
      <item value="UUIDX" />
      <item value="Deprecated" />
      <item value="COUNT" />
      <item value="SELECT" />
      <item value="Query Processor Mapping String Pool" />
      <item value="Executor Diagram Compute Result Vo" />
      <item value="Executor Chart Compute Result Vo" />
      <item value="success" />
      <item value="closed" />
      <item value="dynamic-datasource" />
      <item value="dynamic" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="2109" />
        <entry key="ENGLISH" value="2110" />
        <entry key="ARABIC" value="2" />
        <entry key="AFRIKAANS" value="2" />
        <entry key="GERMAN" value="2" />
        <entry key="FRENCH" value="2" />
        <entry key="FILIPINO" value="2" />
        <entry key="HAITIAN_CREOLE" value="1" />
        <entry key="DUTCH" value="1" />
        <entry key="CATALAN" value="1" />
        <entry key="LATIN" value="2" />
        <entry key="LATVIAN" value="1" />
        <entry key="LUXEMBOURGISH" value="1" />
        <entry key="ROMANIAN" value="2" />
        <entry key="MALAGASY" value="1" />
        <entry key="MALTESE" value="1" />
        <entry key="MAORI" value="1" />
        <entry key="HMONG" value="1" />
        <entry key="NORWEGIAN" value="2" />
        <entry key="PORTUGUESE" value="4" />
        <entry key="SWEDISH" value="2" />
        <entry key="WELSH" value="1" />
        <entry key="UZBEK" value="2" />
        <entry key="SPANISH" value="1" />
        <entry key="HAWAIIAN" value="1" />
        <entry key="ITALIAN" value="4" />
        <entry key="HINDI" value="1" />
        <entry key="INDONESIAN" value="4" />
        <entry key="YORUBA" value="1" />
        <entry key="VIETNAMESE" value="4" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1658564284258" />
  </component>
</application>
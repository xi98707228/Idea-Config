<application>
  <component name="AppStorage">
    <option name="newTranslationDialogWidth" value="598" />
    <option name="newTranslationDialogX" value="623" />
    <option name="newTranslationDialogY" value="342" />
    <histories>
      <item value="chart Type" />
      <item value="图表类型" />
      <item value="图表配置记录描述信息" />
      <item value="describe Message" />
      <item value="chart Image Data" />
      <item value="copy Properties" />
      <item value="Classes supporting the org.springframework.beans package, such as utility classes for sorting and holding lists of beans." />
      <item value="Cached Introspection Results" />
      <item value="Property Descriptor" />
      <item value="Data Base Utils" />
      <item value="init Connection" />
      <item value="Lock Visitor" />
      <item value="A capability-based lock with three modes for controlling readwrite access. The state of a StampedLock consists of a version and mode. Lock acquisition methods return a stamp that represents and controls access with respect to a lock state; &quot;try&quot; versions of these methods may instead return the special value zero to represent failure to acquire access. Lock release and conversion methods require stamps as arguments, and fail if they do not match the state of the lock. The three modes are: &lt;ul&gt; &lt;li&gt;&lt;b&gt;Writing.&lt;b&gt; Method {@link writeLock} possibly blocks waiting for exclusive access, returning a stamp that can be used in method {@link unlockWrite} to release the lock. Untimed and timed versions of {@code tryWriteLock} are also provided. When the lock is held in write mode, no read locks may be obtained, and all optimistic read validations will fail. &lt;li&gt; &lt;li&gt;&lt;b&gt;Reading.&lt;b&gt; Method {@link readLock} possibly blocks waiting for non-exclusive access, returning a stamp that can be used in method {@link unlockRead} to release the lock. Untimed and timed versions of {@code tryReadLock} are also provided. &lt;li&gt; &lt;li&gt;&lt;b&gt;Optimistic Reading.&lt;b&gt; Method {@link tryOptimisticRead} returns a non-zero stamp only if the lock is not currently held in write mode. Method {@link validate} returns true if the lock has not been acquired in write mode since obtaining a given stamp. This mode can be thought of as an extremely weak version of a read-lock, that can be broken by a writer at any time. The use of optimistic mode for short read-only code segments often reduces contention and improves throughput. However, its use is inherently fragile. Optimistic read sections should only read fields and hold them in local variables for later use after validation. Fields read while in optimistic mode may be wildly inconsistent, so usage applies only when you are familiar enough with data representations to check consistency andor repeatedly invoke method {@code validate()}. For example, such steps are typically required when first reading an object or array reference, and then accessing one of its fields, elements or methods. &lt;li&gt; &lt;ul&gt; &lt;p&gt;This class also supports methods that conditionally provide conversions across the three modes. For example, method {@link tryConvertToWriteLock} attempts to &quot;upgrade&quot; a mode, returning a valid write stamp if (1) already in writing mode (2) in reading mode and there are no other readers or (3) in optimistic mode and the lock is available. The forms of these methods are designed to help reduce some of the code bloat that otherwise occurs in retry-based designs. &lt;p&gt;StampedLocks are designed for use as internal utilities in the development of thread-safe components. Their use relies on knowledge of the internal properties of the data, objects, and methods they are protecting. They are not reentrant, so locked bodies should not call other unknown methods that may try to re-acquire locks (although you may pass a stamp to other methods that can use or convert it). The use of read lock modes relies on the associated code sections being side-effect-free. Unvalidated optimistic read sections cannot call methods that are not known to tolerate potential inconsistencies. Stamps use finite representations, and are not cryptographically secure (i.e., a valid stamp may be guessable). Stamp values may recycle after (no sooner than) one year of continuous operation. A stamp held without use or validation for longer than this period may fail to validate correctly. StampedLocks are serializable, but always deserialize into initial unlocked state, so they are not useful for remote locking. &lt;p&gt;The scheduling policy of StampedLock does not consistently prefer readers over writers or vice versa. All &quot;try&quot; methods are best-effort and do not necessarily conform to any scheduling or fairness policy. A zero return from any &quot;try&quot; method for acquiring or converting locks does not carry any information about the state of the lock; a subsequent invocation may succeed. &lt;p&gt;Because it supports coordinated usage across multiple lock modes, this class does not directly implement the {@link Lock} or {@link ReadWriteLock} interfaces. However, a StampedLock may be viewed {@link asReadLock()}, {@link asWriteLock()}, or {@link asReadWriteLock()} in applications requiring only the associated set of functionality. &lt;p&gt;&lt;b&gt;Sample Usage.&lt;b&gt; The following illustrates some usage idioms in a class that maintains simple two-dimensional points. The sample code illustrates some trycatch conventions even though they are not strictly needed here because no exceptions can occur in their bodies.&lt;br&gt; &lt;pre&gt;{@code class Point { private double x, y; private final StampedLock sl = new StampedLock(); void move(double deltaX, double deltaY) { an exclusively locked method long stamp = sl.writeLock(); try { x += deltaX; y += deltaY; } finally { sl.unlockWrite(stamp); } } double distanceFromOrigin() { A read-only method long stamp = sl.tryOptimisticRead(); double currentX = x, currentY = y; if (!sl.validate(stamp)) { stamp = sl.readLock(); try { currentX = x; currentY = y; } finally { sl.unlockRead(stamp); } } return Math.sqrt(currentX currentX + currentY currentY); } void moveIfAtOrigin(double newX, double newY) { upgrade Could instead start with optimistic, not read mode long stamp = sl.readLock(); try { while (x == 0.0 &amp;&amp; y == 0.0) { long ws = sl.tryConvertToWriteLock(stamp); if (ws != 0L) { stamp = ws; x = newX; y = newY; break; } else { sl.unlockRead(stamp); stamp = sl.writeLock(); } } } finally { sl.unlock(stamp); } } }}&lt;pre&gt; @since 1.8 @author Doug Lea" />
      <item value="Singleton Lan Han" />
      <item value="get Instance" />
      <item value="Head of CLH queue" />
      <item value="Wait nodes" />
      <item value="Stamped Lock" />
      <item value="Transaction" />
      <item value="plan Array Method" />
      <item value="read Object" />
      <item value="Stream Corrupted Exception" />
      <item value="default Write Object" />
      <item value="internal Write Entries" />
      <item value="Reads all the bytes from a file. The method ensures that the file is closed when all bytes have been read or an IO error, or other runtime exception, is thrown. &lt;p&gt; Note that this method is intended for simple cases where it is convenient to read all bytes into a byte array. It is not intended for reading in large files." />
      <item value="new" />
      <item value="file Input Stream" />
      <item value="Socket Exception" />
      <item value="file Byte" />
      <item value="wr" />
      <item value="File Input Stream" />
      <item value="Datagram Socket" />
      <item value="main" />
      <item value="datagram Packet" />
      <item value="args" />
      <item value="implements" />
      <item value="file Name" />
      <item value="Datagram Packet" />
      <item value="File Send Client" />
      <item value="Datagram Channel" />
      <item value="Utility class for HTML form encoding. This class contains static methods for converting a String to the &lt;CODE&gt;applicationx-www-form-urlencoded&lt;CODE&gt; MIME format. For more information about HTML form encoding, consult the HTML &lt;A HREF=&quot;http:www.w3.orgTRhtml4&quot;&gt;specification&lt;A&gt;. &lt;p&gt; When encoding a String, the following rules apply: &lt;ul&gt; &lt;li&gt;The alphanumeric characters &amp;quot;{@code a}&amp;quot; through &amp;quot;{@code z}&amp;quot;, &amp;quot;{@code A}&amp;quot; through &amp;quot;{@code Z}&amp;quot; and &amp;quot;{@code 0}&amp;quot; through &amp;quot;{@code 9}&amp;quot; remain the same. &lt;li&gt;The special characters &amp;quot;{@code .}&amp;quot;, &amp;quot;{@code -}&amp;quot;, &amp;quot;{@code }&amp;quot;, and &amp;quot;{@code _}&amp;quot; remain the same. &lt;li&gt;The space character &amp;quot; &amp;nbsp; &amp;quot; is converted into a plus sign &amp;quot;{@code +}&amp;quot;. &lt;li&gt;All other characters are unsafe and are first converted into one or more bytes using some encoding scheme. Then each byte is represented by the 3-character string &amp;quot;&lt;i&gt;{@code %xy}&lt;i&gt;&amp;quot;, where &lt;i&gt;xy&lt;i&gt; is the two-digit hexadecimal representation of the byte. The recommended encoding scheme to use is UTF-8. However, for compatibility reasons, if an encoding is not specified, then the default encoding of the platform is used. &lt;ul&gt; &lt;p&gt; For example using UTF-8 as the encoding scheme the string &amp;quot;The string &amp;252;@foo-bar&amp;quot; would get converted to &amp;quot;The+string+%C3%BC%40foo-bar&amp;quot; because in UTF-8 the character &amp;252; is encoded as two bytes C3 (hex) and BC (hex), and the character @ is encoded as one byte 40 (hex)." />
      <item value="silently discard the offending packet and continue: unknownmalicious entities on nets should not make runtime throw security exception and disrupt the applet by sending random datagram packets." />
      <item value="receive" />
      <item value="Can listen &amp; send on the same socket:" />
      <item value="Auto-assign port number:" />
      <item value="exec" />
      <item value="private static native void initIDs();" />
      <item value="Multicast Socket" />
      <item value="打印出当前数据报包数据" />
      <item value="address" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="2455" />
        <entry key="ENGLISH" value="2456" />
        <entry key="ALBANIAN" value="1" />
        <entry key="ARABIC" value="2" />
        <entry key="ICELANDIC" value="1" />
        <entry key="AFRIKAANS" value="2" />
        <entry key="GERMAN" value="2" />
        <entry key="FRENCH" value="2" />
        <entry key="FILIPINO" value="2" />
        <entry key="HAITIAN_CREOLE" value="2" />
        <entry key="DUTCH" value="2" />
        <entry key="CATALAN" value="1" />
        <entry key="LATIN" value="6" />
        <entry key="LATVIAN" value="1" />
        <entry key="LUXEMBOURGISH" value="2" />
        <entry key="ROMANIAN" value="3" />
        <entry key="MALAGASY" value="1" />
        <entry key="MALTESE" value="1" />
        <entry key="MAORI" value="1" />
        <entry key="HMONG" value="1" />
        <entry key="NORWEGIAN" value="3" />
        <entry key="PORTUGUESE" value="4" />
        <entry key="SWEDISH" value="2" />
        <entry key="WELSH" value="2" />
        <entry key="UZBEK" value="2" />
        <entry key="SPANISH" value="1" />
        <entry key="HAWAIIAN" value="1" />
        <entry key="ITALIAN" value="6" />
        <entry key="HINDI" value="4" />
        <entry key="INDONESIAN" value="4" />
        <entry key="JAVANESE" value="1" />
        <entry key="YORUBA" value="1" />
        <entry key="VIETNAMESE" value="4" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1658996299585" />
  </component>
</application>
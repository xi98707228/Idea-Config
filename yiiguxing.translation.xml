<application>
  <component name="AppStorage">
    <option name="newTranslationDialogWidth" value="598" />
    <option name="newTranslationDialogX" value="623" />
    <option name="newTranslationDialogY" value="342" />
    <histories>
      <item value="file Type" />
      <item value="图片关联的图表记录row Id" />
      <item value="Chart Data Record" />
      <item value="chart Record Key" />
      <item value="file Path" />
      <item value="upload User Nick" />
      <item value="initial Primary Data" />
      <item value="executor Resolver" />
      <item value="INSTANCE" />
      <item value="Equivalence" />
      <item value="reference Value" />
      <item value="Strength" />
      <item value="local Init" />
      <item value="Health Check Registry" />
      <item value="Discard Oldest Policy" />
      <item value="Caller Runs Policy" />
      <item value="Discard Policy" />
      <item value="Abort Policy" />
      <item value="Abstract Queued Long Synchronizer" />
      <item value="A synchronizer that may be exclusively owned by a thread. This class provides a basis for creating locks and related synchronizers that may entail a notion of ownership. The {@code AbstractOwnableSynchronizer} class itself does not manage or use this information. However, subclasses and tools may use appropriately maintained values to help control and monitor access and provide diagnostics." />
      <item value="get Exclusive Owner Thread" />
      <item value="Lock" />
      <item value="Stamped Lock" />
      <item value="store Chart Json" />
      <item value="describe Message" />
      <item value="存储构建图表的JSON数据" />
      <item value="chart Type" />
      <item value="图表类型" />
      <item value="图表配置记录描述信息" />
      <item value="chart Image Data" />
      <item value="copy Properties" />
      <item value="Classes supporting the org.springframework.beans package, such as utility classes for sorting and holding lists of beans." />
      <item value="Cached Introspection Results" />
      <item value="Property Descriptor" />
      <item value="Data Base Utils" />
      <item value="init Connection" />
      <item value="Lock Visitor" />
      <item value="A capability-based lock with three modes for controlling readwrite access. The state of a StampedLock consists of a version and mode. Lock acquisition methods return a stamp that represents and controls access with respect to a lock state; &quot;try&quot; versions of these methods may instead return the special value zero to represent failure to acquire access. Lock release and conversion methods require stamps as arguments, and fail if they do not match the state of the lock. The three modes are: &lt;ul&gt; &lt;li&gt;&lt;b&gt;Writing.&lt;b&gt; Method {@link writeLock} possibly blocks waiting for exclusive access, returning a stamp that can be used in method {@link unlockWrite} to release the lock. Untimed and timed versions of {@code tryWriteLock} are also provided. When the lock is held in write mode, no read locks may be obtained, and all optimistic read validations will fail. &lt;li&gt; &lt;li&gt;&lt;b&gt;Reading.&lt;b&gt; Method {@link readLock} possibly blocks waiting for non-exclusive access, returning a stamp that can be used in method {@link unlockRead} to release the lock. Untimed and timed versions of {@code tryReadLock} are also provided. &lt;li&gt; &lt;li&gt;&lt;b&gt;Optimistic Reading.&lt;b&gt; Method {@link tryOptimisticRead} returns a non-zero stamp only if the lock is not currently held in write mode. Method {@link validate} returns true if the lock has not been acquired in write mode since obtaining a given stamp. This mode can be thought of as an extremely weak version of a read-lock, that can be broken by a writer at any time. The use of optimistic mode for short read-only code segments often reduces contention and improves throughput. However, its use is inherently fragile. Optimistic read sections should only read fields and hold them in local variables for later use after validation. Fields read while in optimistic mode may be wildly inconsistent, so usage applies only when you are familiar enough with data representations to check consistency andor repeatedly invoke method {@code validate()}. For example, such steps are typically required when first reading an object or array reference, and then accessing one of its fields, elements or methods. &lt;li&gt; &lt;ul&gt; &lt;p&gt;This class also supports methods that conditionally provide conversions across the three modes. For example, method {@link tryConvertToWriteLock} attempts to &quot;upgrade&quot; a mode, returning a valid write stamp if (1) already in writing mode (2) in reading mode and there are no other readers or (3) in optimistic mode and the lock is available. The forms of these methods are designed to help reduce some of the code bloat that otherwise occurs in retry-based designs. &lt;p&gt;StampedLocks are designed for use as internal utilities in the development of thread-safe components. Their use relies on knowledge of the internal properties of the data, objects, and methods they are protecting. They are not reentrant, so locked bodies should not call other unknown methods that may try to re-acquire locks (although you may pass a stamp to other methods that can use or convert it). The use of read lock modes relies on the associated code sections being side-effect-free. Unvalidated optimistic read sections cannot call methods that are not known to tolerate potential inconsistencies. Stamps use finite representations, and are not cryptographically secure (i.e., a valid stamp may be guessable). Stamp values may recycle after (no sooner than) one year of continuous operation. A stamp held without use or validation for longer than this period may fail to validate correctly. StampedLocks are serializable, but always deserialize into initial unlocked state, so they are not useful for remote locking. &lt;p&gt;The scheduling policy of StampedLock does not consistently prefer readers over writers or vice versa. All &quot;try&quot; methods are best-effort and do not necessarily conform to any scheduling or fairness policy. A zero return from any &quot;try&quot; method for acquiring or converting locks does not carry any information about the state of the lock; a subsequent invocation may succeed. &lt;p&gt;Because it supports coordinated usage across multiple lock modes, this class does not directly implement the {@link Lock} or {@link ReadWriteLock} interfaces. However, a StampedLock may be viewed {@link asReadLock()}, {@link asWriteLock()}, or {@link asReadWriteLock()} in applications requiring only the associated set of functionality. &lt;p&gt;&lt;b&gt;Sample Usage.&lt;b&gt; The following illustrates some usage idioms in a class that maintains simple two-dimensional points. The sample code illustrates some trycatch conventions even though they are not strictly needed here because no exceptions can occur in their bodies.&lt;br&gt; &lt;pre&gt;{@code class Point { private double x, y; private final StampedLock sl = new StampedLock(); void move(double deltaX, double deltaY) { an exclusively locked method long stamp = sl.writeLock(); try { x += deltaX; y += deltaY; } finally { sl.unlockWrite(stamp); } } double distanceFromOrigin() { A read-only method long stamp = sl.tryOptimisticRead(); double currentX = x, currentY = y; if (!sl.validate(stamp)) { stamp = sl.readLock(); try { currentX = x; currentY = y; } finally { sl.unlockRead(stamp); } } return Math.sqrt(currentX currentX + currentY currentY); } void moveIfAtOrigin(double newX, double newY) { upgrade Could instead start with optimistic, not read mode long stamp = sl.readLock(); try { while (x == 0.0 &amp;&amp; y == 0.0) { long ws = sl.tryConvertToWriteLock(stamp); if (ws != 0L) { stamp = ws; x = newX; y = newY; break; } else { sl.unlockRead(stamp); stamp = sl.writeLock(); } } } finally { sl.unlock(stamp); } } }}&lt;pre&gt; @since 1.8 @author Doug Lea" />
      <item value="Singleton Lan Han" />
      <item value="get Instance" />
      <item value="Head of CLH queue" />
      <item value="Wait nodes" />
      <item value="Transaction" />
      <item value="plan Array Method" />
      <item value="read Object" />
      <item value="Stream Corrupted Exception" />
      <item value="default Write Object" />
      <item value="internal Write Entries" />
      <item value="Reads all the bytes from a file. The method ensures that the file is closed when all bytes have been read or an IO error, or other runtime exception, is thrown. &lt;p&gt; Note that this method is intended for simple cases where it is convenient to read all bytes into a byte array. It is not intended for reading in large files." />
      <item value="new" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="2484" />
        <entry key="ENGLISH" value="2485" />
        <entry key="ALBANIAN" value="1" />
        <entry key="ARABIC" value="2" />
        <entry key="ICELANDIC" value="1" />
        <entry key="AFRIKAANS" value="2" />
        <entry key="GERMAN" value="2" />
        <entry key="FRENCH" value="2" />
        <entry key="FILIPINO" value="2" />
        <entry key="HAITIAN_CREOLE" value="2" />
        <entry key="DUTCH" value="2" />
        <entry key="CATALAN" value="1" />
        <entry key="LATIN" value="6" />
        <entry key="LATVIAN" value="1" />
        <entry key="LUXEMBOURGISH" value="2" />
        <entry key="ROMANIAN" value="3" />
        <entry key="MALAGASY" value="1" />
        <entry key="MALTESE" value="1" />
        <entry key="MAORI" value="1" />
        <entry key="HMONG" value="1" />
        <entry key="NORWEGIAN" value="3" />
        <entry key="PORTUGUESE" value="4" />
        <entry key="SWEDISH" value="2" />
        <entry key="WELSH" value="2" />
        <entry key="UZBEK" value="2" />
        <entry key="SPANISH" value="1" />
        <entry key="HAWAIIAN" value="1" />
        <entry key="ITALIAN" value="6" />
        <entry key="HINDI" value="4" />
        <entry key="INDONESIAN" value="4" />
        <entry key="JAVANESE" value="1" />
        <entry key="YORUBA" value="1" />
        <entry key="VIETNAMESE" value="4" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1658996299585" />
  </component>
</application>
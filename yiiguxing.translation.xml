<application>
  <component name="AppStorage">
    <option name="newTranslationDialogWidth" value="598" />
    <option name="newTranslationDialogX" value="623" />
    <option name="newTranslationDialogY" value="342" />
    <option name="pinTranslationDialog" value="true" />
    <histories>
      <item value="Handles cases of updates involving initialization, resizing, creating new Cells, andor contention. See above for explanation. This method suffers the usual non-modularity problems of optimistic retry code, relying on rechecked sets of reads. @param x the value @param fn the update function, or null for add (this convention avoids the need for an extra field or function in LongAdder). @param wasUncontended false if CAS failed before call" />
      <item value="long Accumulate" />
      <item value="Number of CPUS, to place bound on table size" />
      <item value="Double Adder" />
      <item value="Double Accumulator" />
      <item value="This class maintains a lazily-initialized table of atomically updated variables, plus an extra &quot;base&quot; field. The table size is a power of two. Indexing uses masked per-thread hash codes. Nearly all declarations in this class are package-private, accessed directly by subclasses. Table entries are of class Cell; a variant of AtomicLong padded (via @sun.misc.Contended) to reduce cache contention. Padding is overkill for most Atomics because they are usually irregularly scattered in memory and thus don't interfere much with each other. But Atomic objects residing in arrays will tend to be placed adjacent to each other, and so will most often share cache lines (with a huge negative performance impact) without this precaution. In part because Cells are relatively large, we avoid creating them until they are needed. When there is no contention, all updates are made to the base field. Upon first contention (a failed CAS on base update), the table is initialized to size 2. The table size is doubled upon further contention until reaching the nearest power of two greater than or equal to the number of CPUS. Table slots remain empty (null) until they are needed. A single spinlock (&quot;cellsBusy&quot;) is used for initializing and resizing the table, as well as populating slots with new Cells. There is no need for a blocking lock; when the lock is not available, threads try other slots (or the base). During these retries, there is increased contention and reduced locality, which is still better than alternatives. The Thread probe fields maintained via ThreadLocalRandom serve as per-thread hash codes. We let them remain uninitialized as zero (if they come in this way) until they contend at slot 0. They are then initialized to values that typically do not often conflict with others. Contention andor table collisions are indicated by failed CASes when performing an update operation. Upon a collision, if the table size is less than the capacity, it is doubled in size unless some other thread holds the lock. If a hashed slot is empty, and lock is available, a new Cell is created. Otherwise, if the slot exists, a CAS is tried. Retries proceed by &quot;double hashing&quot;, using a secondary hash (Marsaglia XorShift) to try to find a free slot. The table size is capped because, when there are more threads than CPUs, supposing that each thread were bound to a CPU, there would exist a perfect hash function mapping threads to slots that eliminates collisions. When we reach capacity, we search for this mapping by randomly varying the hash codes of colliding threads. Because search is random, and collisions only become known via CAS failures, convergence can be slow, and because threads are typically not bound to CPUS forever, may not occur at all. However, despite these limitations, observed contention rates are typically low in these cases. It is possible for a Cell to become unused when threads that once hashed to it terminate, as well as in the case where doubling the table causes no thread to hash to it under expanded mask. We do not try to detect or remove such cells, under the assumption that for long-running instances, observed contention levels will recur, so the cells will eventually be needed again; and for short-lived ones, it does not matter." />
      <item value="A package-local class holding common representation and mechanics for classes supporting dynamic striping on 64bit values. The class extends Number so that concrete subclasses must publicly do so." />
      <item value="Contended" />
      <item value="Striped 64" />
      <item value="Serialization proxy, used to avoid reference to the non-public Striped64 superclass in serialized forms. @serial include" />
      <item value="Access to bits, native and otherwise." />
      <item value="Monitoring of direct buffer usage" />
      <item value="copy From Long Array" />
      <item value="native Order" />
      <item value="Direct Double Buffer RU" />
      <item value="A byte buffer. &lt;p&gt; This class defines six categories of operations upon byte buffers: &lt;ul&gt; &lt;li&gt;&lt;p&gt; Absolute and relative {@link get() &lt;i&gt;get&lt;i&gt;} and {@link put(byte) &lt;i&gt;put&lt;i&gt;} methods that read and write single bytes; &lt;p&gt;&lt;li&gt; &lt;li&gt;&lt;p&gt; Relative {@link get(byte[]) &lt;i&gt;bulk get&lt;i&gt;} methods that transfer contiguous sequences of bytes from this buffer into an array; &lt;p&gt;&lt;li&gt; &lt;li&gt;&lt;p&gt; Relative {@link put(byte[]) &lt;i&gt;bulk put&lt;i&gt;} methods that transfer contiguous sequences of bytes from a byte array or some other byte buffer into this buffer; &lt;p&gt;&lt;li&gt; &lt;li&gt;&lt;p&gt; Absolute and relative {@link getChar() &lt;i&gt;get&lt;i&gt;} and {@link putChar(char) &lt;i&gt;put&lt;i&gt;} methods that read and write values of other primitive types, translating them to and from sequences of bytes in a particular byte order; &lt;p&gt;&lt;li&gt; &lt;li&gt;&lt;p&gt; Methods for creating &lt;i&gt;&lt;a href=&quot;views&quot;&gt;view buffers&lt;a&gt;&lt;i&gt;, which allow a byte buffer to be viewed as a buffer containing values of some other primitive type; and &lt;p&gt;&lt;li&gt; &lt;li&gt;&lt;p&gt; Methods for {@link compact compacting}, {@link duplicate duplicating}, and {@link slice slicing} a byte buffer. &lt;p&gt;&lt;li&gt; &lt;ul&gt; &lt;p&gt; Byte buffers can be created either by {@link allocate &lt;i&gt;allocation&lt;i&gt;}, which allocates space for the buffer's content, or by {@link wrap(byte[]) &lt;i&gt;wrapping&lt;i&gt;} an existing byte array into a buffer. &lt;a name=&quot;direct&quot;&gt;&lt;a&gt; &lt;h2&gt; Direct &lt;i&gt;vs.&lt;i&gt; non-direct buffers &lt;h2&gt; &lt;p&gt; A byte buffer is either &lt;i&gt;direct&lt;i&gt; or &lt;i&gt;non-direct&lt;i&gt;. Given a direct byte buffer, the Java virtual machine will make a best effort to perform native IO operations directly upon it. That is, it will attempt to avoid copying the buffer's content to (or from) an intermediate buffer before (or after) each invocation of one of the underlying operating system's native IO operations. &lt;p&gt; A direct byte buffer may be created by invoking the {@link allocateDirect(int) allocateDirect} factory method of this class. The buffers returned by this method typically have somewhat higher allocation and deallocation costs than non-direct buffers. The contents of direct buffers may reside outside of the normal garbage-collected heap, and so their impact upon the memory footprint of an application might not be obvious. It is therefore recommended that direct buffers be allocated primarily for large, long-lived buffers that are subject to the underlying system's native IO operations. In general it is best to allocate direct buffers only when they yield a measureable gain in program performance. &lt;p&gt; A direct byte buffer may also be created by {@link java.nio.channels.FileChannelmap mapping} a region of a file directly into memory. An implementation of the Java platform may optionally support the creation of direct byte buffers from native code via JNI. If an instance of one of these kinds of buffers refers to an inaccessible region of memory then an attempt to access that region will not change the buffer's content and will cause an unspecified exception to be thrown either at the time of the access or at some later time. &lt;p&gt; Whether a byte buffer is direct or non-direct may be determined by invoking its {@link isDirect isDirect} method. This method is provided so that explicit buffer management can be done in performance-critical code. &lt;a name=&quot;bin&quot;&gt;&lt;a&gt; &lt;h2&gt; Access to binary data &lt;h2&gt; &lt;p&gt; This class defines methods for reading and writing values of all other primitive types, except &lt;tt&gt;boolean&lt;tt&gt;. Primitive values are translated to (or from) sequences of bytes according to the buffer's current byte order, which may be retrieved and modified via the {@link order order} methods. Specific byte orders are represented by instances of the {@link ByteOrder} class. The initial order of a byte buffer is always {@link ByteOrderBIG_ENDIAN BIG_ENDIAN}. &lt;p&gt; For access to heterogeneous binary data, that is, sequences of values of different types, this class defines a family of absolute and relative &lt;i&gt;get&lt;i&gt; and &lt;i&gt;put&lt;i&gt; methods for each type. For 32-bit floating-point values, for example, this class defines: &lt;blockquote&gt;&lt;pre&gt; float {@link getFloat()} float {@link getFloat(int) getFloat(int index)} void {@link putFloat(float) putFloat(float f)} void {@link putFloat(int,float) putFloat(int index, float f)}&lt;pre&gt;&lt;blockquote&gt; &lt;p&gt; Corresponding methods are defined for the types &lt;tt&gt;char&lt;tt&gt;, &lt;tt&gt;short&lt;tt&gt;, &lt;tt&gt;int&lt;tt&gt;, &lt;tt&gt;long&lt;tt&gt;, and &lt;tt&gt;double&lt;tt&gt;. The index parameters of the absolute &lt;i&gt;get&lt;i&gt; and &lt;i&gt;put&lt;i&gt; methods are in terms of bytes rather than of the type being read or written. &lt;a name=&quot;views&quot;&gt;&lt;a&gt; &lt;p&gt; For access to homogeneous binary data, that is, sequences of values of the same type, this class defines methods that can create &lt;i&gt;views&lt;i&gt; of a given byte buffer. A &lt;i&gt;view buffer&lt;i&gt; is simply another buffer whose content is backed by the byte buffer. Changes to the byte buffer's content will be visible in the view buffer, and vice versa; the two buffers' position, limit, and mark values are independent. The {@link asFloatBuffer() asFloatBuffer} method, for example, creates an instance of the {@link FloatBuffer} class that is backed by the byte buffer upon which the method is invoked. Corresponding view-creation methods are defined for the types &lt;tt&gt;char&lt;tt&gt;, &lt;tt&gt;short&lt;tt&gt;, &lt;tt&gt;int&lt;tt&gt;, &lt;tt&gt;long&lt;tt&gt;, and &lt;tt&gt;double&lt;tt&gt;. &lt;p&gt; View buffers have three important advantages over the families of type-specific &lt;i&gt;get&lt;i&gt; and &lt;i&gt;put&lt;i&gt; methods described above: &lt;ul&gt; &lt;li&gt;&lt;p&gt; A view buffer is indexed not in terms of bytes but rather in terms of the type-specific size of its values; &lt;p&gt;&lt;li&gt; &lt;li&gt;&lt;p&gt; A view buffer provides relative bulk &lt;i&gt;get&lt;i&gt; and &lt;i&gt;put&lt;i&gt; methods that can transfer contiguous sequences of values between a buffer and an array or some other buffer of the same type; and &lt;p&gt;&lt;li&gt; &lt;li&gt;&lt;p&gt; A view buffer is potentially much more efficient because it will be direct if, and only if, its backing byte buffer is direct. &lt;p&gt;&lt;li&gt; &lt;ul&gt; &lt;p&gt; The byte order of a view buffer is fixed to be that of its byte buffer at the time that the view is created. &lt;p&gt; &lt;h2&gt; Invocation chaining &lt;h2&gt; &lt;p&gt; Methods in this class that do not otherwise have a value to return are specified to return the buffer upon which they are invoked. This allows method invocations to be chained. The sequence of statements &lt;blockquote&gt;&lt;pre&gt; bb.putInt(0xCAFEBABE); bb.putShort(3); bb.putShort(45);&lt;pre&gt;&lt;blockquote&gt; can, for example, be replaced by the single statement &lt;blockquote&gt;&lt;pre&gt; bb.putInt(0xCAFEBABE).putShort(3).putShort(45);&lt;pre&gt;&lt;blockquote&gt;" />
      <item value="Interrupts threads that might be waiting for tasks (as indicated by not being locked) so they can check for termination or configuration changes. Ignores SecurityExceptions (in which case some threads may remain uninterrupted). @param onlyOne If true, interrupt at most one worker. This is called only from tryTerminate when termination is otherwise enabled but there are still other workers. In this case, at most one waiting worker is interrupted to propagate shutdown signals in case all threads are currently waiting. Interrupting any arbitrary thread ensures that newly arriving workers since shutdown began will also eventually exit. To guarantee eventual termination, it suffices to always interrupt only one idle worker, but shutdown() interrupts all idle workers so that redundant workers exit promptly, not waiting for a straggler task to finish." />
      <item value="only One" />
      <item value="interrupt Idle Workers" />
      <item value="advance Run State" />
      <item value="Caller Sensitive" />
      <item value="is System Domain Loader" />
      <item value="get Resource" />
      <item value="url" />
      <item value="update Status" />
      <item value="AUTOCONFIG FILE" />
      <item value="is Right Code" />
      <item value="hb Vehicle" />
      <item value="method" />
      <item value="place No" />
      <item value="车牌号" />
      <item value="_flag" />
      <item value="Filter Chain" />
      <item value="Http Servlet Request" />
      <item value="host" />
      <item value="urlurl" />
      <item value="Catalina" />
      <item value="catalina" />
      <item value="numerTemp -&gt; contractReview -&gt; reportManage" />
      <item value="James House" />
      <item value="Trigger Fired Bundle" />
      <item value="notify Scheduler Thread" />
      <item value="pause Job" />
      <item value="Quartz Disallow Concurrent Execution" />
      <item value="Quartz Job Execution" />
      <item value="RUNTIME" />
      <item value="Soap Fault Exception" />
      <item value="Juergen Hoeller" />
      <item value="DEFAULT EXCLUSION FILTER" />
      <item value="collect Imports" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="3784" />
        <entry key="ENGLISH" value="3785" />
        <entry key="ALBANIAN" value="3" />
        <entry key="ARABIC" value="3" />
        <entry key="IRISH" value="2" />
        <entry key="BULGARIAN" value="1" />
        <entry key="ICELANDIC" value="3" />
        <entry key="AFRIKAANS" value="2" />
        <entry key="DANISH" value="2" />
        <entry key="GERMAN" value="2" />
        <entry key="FRENCH" value="2" />
        <entry key="FILIPINO" value="2" />
        <entry key="HAITIAN_CREOLE" value="2" />
        <entry key="DUTCH" value="2" />
        <entry key="CATALAN" value="2" />
        <entry key="KANNADA" value="1" />
        <entry key="LATIN" value="11" />
        <entry key="LATVIAN" value="1" />
        <entry key="LUXEMBOURGISH" value="3" />
        <entry key="ROMANIAN" value="5" />
        <entry key="MALAGASY" value="1" />
        <entry key="MALTESE" value="2" />
        <entry key="MAORI" value="1" />
        <entry key="HMONG" value="1" />
        <entry key="NORWEGIAN" value="3" />
        <entry key="PORTUGUESE" value="7" />
        <entry key="JAPANESE" value="1" />
        <entry key="SWEDISH" value="2" />
        <entry key="SLOVENIAN" value="1" />
        <entry key="WELSH" value="2" />
        <entry key="UZBEK" value="2" />
        <entry key="SPANISH" value="6" />
        <entry key="HAWAIIAN" value="2" />
        <entry key="HUNGARIAN" value="1" />
        <entry key="ITALIAN" value="6" />
        <entry key="HINDI" value="4" />
        <entry key="INDONESIAN" value="4" />
        <entry key="JAVANESE" value="1" />
        <entry key="YORUBA" value="1" />
        <entry key="VIETNAMESE" value="4" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1659860808522" />
  </component>
</application>
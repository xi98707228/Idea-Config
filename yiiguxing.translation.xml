<application>
  <component name="AppStorage">
    <histories>
      <item value="Stream Decoder" />
      <item value="Win 32 Error Mode" />
      <item value="for Input Stream Reader" />
      <item value="remaining" />
      <item value="The object used to synchronize operations on this stream. For efficiency, a character-stream object may use an object other than itself to protect critical sections. A subclass should therefore use the object in this field rather than &lt;tt&gt;this&lt;tt&gt; or a synchronized method." />
      <item value="Mark Reinhold" />
      <item value="try Acquire Shared Nanos" />
      <item value="release" />
      <item value="Not quite a no-op; ensures volatile write semantics" />
      <item value="A thread-safe variant of {@link java.util.ArrayList} in which all mutative operations ({@code add}, {@code set}, and so on) are implemented by making a fresh copy of the underlying array. &lt;p&gt;This is ordinarily too costly, but may be &lt;em&gt;more&lt;em&gt; efficient than alternatives when traversal operations vastly outnumber mutations, and is useful when you cannot or don't want to synchronize traversals, yet need to preclude interference among concurrent threads. The &quot;snapshot&quot; style iterator method uses a reference to the state of the array at the point that the iterator was created. This array never changes during the lifetime of the iterator, so interference is impossible and the iterator is guaranteed not to throw {@code ConcurrentModificationException}. The iterator will not reflect additions, removals, or changes to the list since the iterator was created. Element-changing operations on iterators themselves ({@code remove}, {@code set}, and {@code add}) are not supported. These methods throw {@code UnsupportedOperationException}. &lt;p&gt;All elements are permitted, including {@code null}. &lt;p&gt;Memory consistency effects: As with other concurrent collections, actions in a thread prior to placing an object into a {@code CopyOnWriteArrayList} &lt;a href=&quot;package-summary.htmlMemoryVisibility&quot;&gt;&lt;i&gt;happen-before&lt;i&gt;&lt;a&gt; actions subsequent to the access or removal of that element from the {@code CopyOnWriteArrayList} in another thread. &lt;p&gt;This class is a member of the &lt;a href=&quot;{@docRoot}..technotesguidescollectionsindex.html&quot;&gt; Java Collections Framework&lt;a&gt;." />
      <item value="get Component Type" />
      <item value="Buffer" />
      <item value="Char Buffer" />
      <item value="Readable" />
      <item value="seek" />
      <item value="poiniter" />
      <item value="Random Access File Factory" />
      <item value="Factory" />
      <item value="read Unsigned Byte" />
      <item value="available" />
      <item value="ckage" />
      <item value="Test Eof" />
      <item value="Skip a leftover '\n', if necessary" />
      <item value="David Connelly" />
      <item value="Jonathan Payne" />
      <item value="The position within the pushback buffer from which the next byte will be read. When the buffer is empty, &lt;code&gt;pos&lt;code&gt; is equal to &lt;code&gt;buf.length&lt;code&gt;; when the buffer is full, &lt;code&gt;pos&lt;code&gt; is equal to zero." />
      <item value="unread" />
      <item value="Pushback Input Stream" />
      <item value="If a security manager exists and its &lt;code&gt;{@link java.lang.SecurityManagercheckWrite(java.lang.String)}&lt;code&gt; method denies write access to the file" />
      <item value="If an IO error occurred" />
      <item value="&lt;code&gt;true&lt;code&gt; if the named file does not exist and was successfully created; &lt;code&gt;false&lt;code&gt; if the named file already exists" />
      <item value="Atomically creates a new, empty file named by this abstract pathname if and only if a file with this name does not yet exist. The check for the existence of the file and the creation of the file if it does not exist are a single operation that is atomic with respect to all other filesystem activities that might affect the file. &lt;P&gt; Note: this method should &lt;i&gt;not&lt;i&gt; be used for file-locking, as the resulting protocol cannot be made to work reliably. The {@link java.nio.channels.FileLock FileLock} facility should be used instead. @return &lt;code&gt;true&lt;code&gt; if the named file does not exist and was successfully created; &lt;code&gt;false&lt;code&gt; if the named file already exists @throws IOException If an IO error occurred @throws SecurityException If a security manager exists and its &lt;code&gt;{@link java.lang.SecurityManagercheckWrite(java.lang.String)}&lt;code&gt; method denies write access to the file @since 1.2" />
      <item value="Ho Hum Exception" />
      <item value="Atomically creates a new, empty file named by this abstract pathname if and only if a file with this name does not yet exist. The check for the existence of the file and the creation of the file if it does not exist are a single operation that is atomic with respect to all other filesystem activities that might affect the file. &lt;P&gt; Note: this method should &lt;i&gt;not&lt;i&gt; be used for file-locking, as the resulting protocol cannot be made to work reliably. The {@link java.nio.channels.FileLock FileLock} facility should be used instead." />
      <item value="Creates the directory named by this abstract pathname." />
      <item value="Deletes the file or directory denoted by this abstract pathname. If this pathname denotes a directory, then the directory must be empty in order to be deleted." />
      <item value="Tests whether the file or directory denoted by this abstract pathname exists." />
      <item value="again" />
      <item value="Flushable" />
      <item value="Track both the text- and character-output streams, so that their buffers can be flushed without flushing the entire stream." />
      <item value="The underlying output stream to be filtered." />
      <item value="This class is the superclass of all classes that filter output streams. These streams sit on top of an already existing output stream (the &lt;i&gt;underlying&lt;i&gt; output stream) which it uses as its basic sink of data, but possibly transforming the data along the way or providing additional functionality. &lt;p&gt; The class &lt;code&gt;FilterOutputStream&lt;code&gt; itself simply overrides all methods of &lt;code&gt;OutputStream&lt;code&gt; with versions that pass all requests to the underlying output stream. Subclasses of &lt;code&gt;FilterOutputStream&lt;code&gt; may further override some of these methods as well as provide additional methods and fields." />
      <item value="Snmp Table Cache" />
      <item value="Jvm RT Class Path Table Meta Impl" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="45" />
        <entry key="ENGLISH" value="46" />
        <entry key="HMONG" value="1" />
        <entry key="HINDI" value="1" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1655556977798" />
  </component>
</application>
<application>
  <component name="AppStorage">
    <option name="newTranslationDialogWidth" value="598" />
    <option name="newTranslationDialogX" value="623" />
    <option name="newTranslationDialogY" value="342" />
    <histories>
      <item value="demo Thread 1" />
      <item value="Toggle" />
      <item value="Window Adapter" />
      <item value="add" />
      <item value="run Flag" />
      <item value="templateserver" />
      <item value="String" />
      <item value="MERGE COUNT" />
      <item value="MERGE VALUE SUM" />
      <item value="get Field Name" />
      <item value="field Name" />
      <item value="Chart Field Config" />
      <item value="field Value" />
      <item value="merge Result Type" />
      <item value="必须填写当前字段对应的数值" />
      <item value="进行合并值" />
      <item value="table Name" />
      <item value="Chart Field Config Controller" />
      <item value="前端填充的字段配置信息" />
      <item value="save Field Config" />
      <item value="utils" />
      <item value="template Manage" />
      <item value="project" />
      <item value="package" />
      <item value="Service" />
      <item value="HB Compute Scale Strategy" />
      <item value="Marks a constructor, field, setter method, or config method as to be autowired by Spring's dependency injection facilities. This is an alternative to the JSR-330 {@link javax.inject.Inject} annotation, adding required-vs-optional semantics. &lt;h3&gt;Autowired Constructors&lt;h3&gt; &lt;p&gt;Only one constructor of any given bean class may declare this annotation with the {@link required} attribute set to {@code true}, indicating &lt;i&gt;the&lt;i&gt; constructor to autowire when used as a Spring bean. Furthermore, if the {@code required} attribute is set to {@code true}, only a single constructor may be annotated with {@code @Autowired}. If multiple &lt;i&gt;non-required&lt;i&gt; constructors declare the annotation, they will be considered as candidates for autowiring. The constructor with the greatest number of dependencies that can be satisfied by matching beans in the Spring container will be chosen. If none of the candidates can be satisfied, then a primarydefault constructor (if present) will be used. Similarly, if a class declares multiple constructors but none of them is annotated with {@code @Autowired}, then a primarydefault constructor (if present) will be used. If a class only declares a single constructor to begin with, it will always be used, even if not annotated. An annotated constructor does not have to be public. &lt;h3&gt;Autowired Fields&lt;h3&gt; &lt;p&gt;Fields are injected right after construction of a bean, before any config methods are invoked. Such a config field does not have to be public. &lt;h3&gt;Autowired Methods&lt;h3&gt; &lt;p&gt;Config methods may have an arbitrary name and any number of arguments; each of those arguments will be autowired with a matching bean in the Spring container. Bean property setter methods are effectively just a special case of such a general config method. Such config methods do not have to be public. &lt;h3&gt;Autowired Parameters&lt;h3&gt; &lt;p&gt;Although {@code @Autowired} can technically be declared on individual method or constructor parameters since Spring Framework 5.0, most parts of the framework ignore such declarations. The only part of the core Spring Framework that actively supports autowired parameters is the JUnit Jupiter support in the {@code spring-test} module (see the &lt;a href=&quot;https:docs.spring.iospringdocscurrentspring-framework-referencetesting.htmltestcontext-junit-jupiter-di&quot;&gt;TestContext framework&lt;a&gt; reference documentation for details). &lt;h3&gt;Multiple Arguments and 'required' Semantics&lt;h3&gt; &lt;p&gt;In the case of a multi-arg constructor or method, the {@link required} attribute is applicable to all arguments. Individual parameters may be declared as Java-8 style {@link java.util.Optional} or, as of Spring Framework 5.0, also as {@code @Nullable} or a not-null parameter type in Kotlin, overriding the base 'required' semantics. &lt;h3&gt;Autowiring Arrays, Collections, and Maps&lt;h3&gt; &lt;p&gt;In case of an array, {@link java.util.Collection}, or {@link java.util.Map} dependency type, the container autowires all beans matching the declared value type. For such purposes, the map keys must be declared as type {@code String} which will be resolved to the corresponding bean names. Such a container-provided collection will be ordered, taking into account {@link org.springframework.core.Ordered Ordered} and {@link org.springframework.core.annotation.Order @Order} values of the target components, otherwise following their registration order in the container. Alternatively, a single matching target bean may also be a generally typed {@code Collection} or {@code Map} itself, getting injected as such. &lt;h3&gt;Not supported in {@code BeanPostProcessor} or {@code BeanFactoryPostProcessor}&lt;h3&gt; &lt;p&gt;Note that actual injection is performed through a {@link org.springframework.beans.factory.config.BeanPostProcessor BeanPostProcessor} which in turn means that you &lt;em&gt;cannot&lt;em&gt; use {@code @Autowired} to inject references into {@link org.springframework.beans.factory.config.BeanPostProcessor BeanPostProcessor} or {@link org.springframework.beans.factory.config.BeanFactoryPostProcessor BeanFactoryPostProcessor} types. Please consult the javadoc for the {@link AutowiredAnnotationBeanPostProcessor} class (which, by default, checks for the presence of this annotation). @author Juergen Hoeller @author Mark Fisher @author Sam Brannen @since 2.5 @see AutowiredAnnotationBeanPostProcessor @see Qualifier @see Value" />
      <item value="get Data Table" />
      <item value="chart Config Record Service" />
      <item value="record" />
      <item value="operate Data" />
      <item value="Security Utils" />
      <item value="matches Password" />
      <item value="Date" />
      <item value="set Update Time" />
      <item value="set Update User Nick" />
      <item value="save Or Update" />
      <item value="Data Base Utils" />
      <item value="declaring Class" />
      <item value="ordinal" />
      <item value="Pascal Case" />
      <item value="Camel Case" />
      <item value="No Change" />
      <item value="Never Use This Value Except Default Value" />
      <item value="Property Naming Strategy" />
      <item value="Users" />
      <item value="print If Info Enabled" />
      <item value="config Describe Message" />
      <item value="config Title" />
      <item value="Comparison and hashing" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="1952" />
        <entry key="ENGLISH" value="1953" />
        <entry key="ARABIC" value="2" />
        <entry key="AFRIKAANS" value="2" />
        <entry key="GERMAN" value="1" />
        <entry key="FRENCH" value="2" />
        <entry key="FILIPINO" value="2" />
        <entry key="HAITIAN_CREOLE" value="1" />
        <entry key="DUTCH" value="1" />
        <entry key="CATALAN" value="1" />
        <entry key="LATIN" value="2" />
        <entry key="LUXEMBOURGISH" value="1" />
        <entry key="ROMANIAN" value="2" />
        <entry key="MALTESE" value="1" />
        <entry key="MAORI" value="1" />
        <entry key="HMONG" value="1" />
        <entry key="NORWEGIAN" value="2" />
        <entry key="PORTUGUESE" value="4" />
        <entry key="SWEDISH" value="2" />
        <entry key="SPANISH" value="1" />
        <entry key="HAWAIIAN" value="1" />
        <entry key="ITALIAN" value="4" />
        <entry key="HINDI" value="1" />
        <entry key="INDONESIAN" value="4" />
        <entry key="YORUBA" value="1" />
        <entry key="VIETNAMESE" value="4" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1658564284258" />
  </component>
</application>
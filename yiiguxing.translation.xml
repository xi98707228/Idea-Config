<application>
  <component name="AppStorage">
    <option name="newTranslationDialogWidth" value="598" />
    <option name="newTranslationDialogX" value="623" />
    <option name="newTranslationDialogY" value="342" />
    <option name="pinTranslationDialog" value="true" />
    <histories>
      <item value="SIGNAL" />
      <item value="The number of nanoseconds for which it is faster to spin rather than to use timed park. A rough estimate suffices to improve responsiveness with very short timeouts." />
      <item value="spin For Timeout Threshold" />
      <item value="SHARED" />
      <item value="Returns the current value of synchronization state. This operation has memory semantics of a {@code volatile} read. @return current state value" />
      <item value="ecrement count; signal when transition to zero" />
      <item value="compare And Set State" />
      <item value="The synchronization state." />
      <item value="Lock methods The value 0 represents the unlocked state. The value 1 represents the locked state." />
      <item value="Creates with given first task and thread from ThreadFactory. @param firstTask the first task (null if none)" />
      <item value="inhibit interrupts until runWorker" />
      <item value="Abstract Queued Synchronizer" />
      <item value="Default Thread Factory" />
      <item value="group" />
      <item value="name Prefix" />
      <item value="Delegated Executor Service" />
      <item value="await Termination" />
      <item value="Event Executor Group" />
      <item value="Rejected Execution Exception" />
      <item value="Null Pointer Exception" />
      <item value="Returns {@code true} if this task completed. Completion may be due to normal termination, an exception, or cancellation -- in all of these cases, this method will return {@code true}. @return {@code true} if this task completed" />
      <item value="the result to return" />
      <item value="Submits a Runnable task for execution and returns a Future representing that task. The Future's {@code get} method will return the given result upon successful completion. @param task the task to submit" />
      <item value="invoke Any" />
      <item value="An {@link Executor} that provides methods to manage termination and methods that can produce a {@link Future} for tracking progress of one or more asynchronous tasks. &lt;p&gt;An {@code ExecutorService} can be shut down, which will cause it to reject new tasks. Two different methods are provided for shutting down an {@code ExecutorService}. The {@link shutdown} method will allow previously submitted tasks to execute before terminating, while the {@link shutdownNow} method prevents waiting tasks from starting and attempts to stop currently executing tasks. Upon termination, an executor has no tasks actively executing, no tasks awaiting execution, and no new tasks can be submitted. An unused {@code ExecutorService} should be shut down to allow reclamation of its resources. &lt;p&gt;Method {@code submit} extends base method {@link Executorexecute(Runnable)} by creating and returning a {@link Future} that can be used to cancel execution andor wait for completion. Methods {@code invokeAny} and {@code invokeAll} perform the most commonly useful forms of bulk execution, executing a collection of tasks and then waiting for at least one, or all, to complete. (Class {@link ExecutorCompletionService} can be used to write customized variants of these methods.) &lt;p&gt;The {@link Executors} class provides factory methods for the executor services provided in this package. &lt;h3&gt;Usage Examples&lt;h3&gt; Here is a sketch of a network service in which threads in a thread pool service incoming requests. It uses the preconfigured {@link ExecutorsnewFixedThreadPool} factory method: &lt;pre&gt; {@code class NetworkService implements Runnable { private final ServerSocket serverSocket; private final ExecutorService pool; public NetworkService(int port, int poolSize) throws IOException { serverSocket = new ServerSocket(port); pool = Executors.newFixedThreadPool(poolSize); } public void run() { run the service try { for (;;) { pool.execute(new Handler(serverSocket.accept())); } } catch (IOException ex) { pool.shutdown(); } } } class Handler implements Runnable { private final Socket socket; Handler(Socket socket) { this.socket = socket; } public void run() { read and service request on socket } }}&lt;pre&gt; The following method shuts down an {@code ExecutorService} in two phases, first by calling {@code shutdown} to reject incoming tasks, and then calling {@code shutdownNow}, if necessary, to cancel any lingering tasks: &lt;pre&gt; {@code void shutdownAndAwaitTermination(ExecutorService pool) { pool.shutdown(); Disable new tasks from being submitted try { Wait a while for existing tasks to terminate if (!pool.awaitTermination(60, TimeUnit.SECONDS)) { pool.shutdownNow(); Cancel currently executing tasks Wait a while for tasks to respond to being cancelled if (!pool.awaitTermination(60, TimeUnit.SECONDS)) System.err.println(&quot;Pool did not terminate&quot;); } } catch (InterruptedException ie) { (Re-)Cancel if current thread also interrupted pool.shutdownNow(); Preserve interrupt status Thread.currentThread().interrupt(); } }}&lt;pre&gt; &lt;p&gt;Memory consistency effects: Actions in a thread prior to the submission of a {@code Runnable} or {@code Callable} task to an {@code ExecutorService} &lt;a href=&quot;package-summary.htmlMemoryVisibility&quot;&gt;&lt;i&gt;happen-before&lt;i&gt;&lt;a&gt; any actions taken by that task, which in turn &lt;i&gt;happen-before&lt;i&gt; the result is retrieved via {@code Future.get()}." />
      <item value="Task" />
      <item value="tasks" />
      <item value="An object that executes submitted {@link Runnable} tasks. This interface provides a way of decoupling task submission from the mechanics of how each task will be run, including details of thread use, scheduling, etc. An {@code Executor} is normally used instead of explicitly creating threads. For example, rather than invoking {@code new Thread(new(RunnableTask())).start()} for each of a set of tasks, you might use: &lt;pre&gt; Executor executor = &lt;em&gt;anExecutor&lt;em&gt;; executor.execute(new RunnableTask1()); executor.execute(new RunnableTask2()); ... &lt;pre&gt; However, the {@code Executor} interface does not strictly require that execution be asynchronous. In the simplest case, an executor can run the submitted task immediately in the caller's thread: &lt;pre&gt; {@code class DirectExecutor implements Executor { public void execute(Runnable r) { r.run(); } }}&lt;pre&gt; More typically, tasks are executed in some thread other than the caller's thread. The executor below spawns a new thread for each task. &lt;pre&gt; {@code class ThreadPerTaskExecutor implements Executor { public void execute(Runnable r) { new Thread(r).start(); } }}&lt;pre&gt; Many {@code Executor} implementations impose some sort of limitation on how and when tasks are scheduled. The executor below serializes the submission of tasks to a second executor, illustrating a composite executor. &lt;pre&gt; {@code class SerialExecutor implements Executor { final Queue&lt;Runnable&gt; tasks = new ArrayDeque&lt;Runnable&gt;(); final Executor executor; Runnable active; SerialExecutor(Executor executor) { this.executor = executor; } public synchronized void execute(final Runnable r) { tasks.offer(new Runnable() { public void run() { try { r.run(); } finally { scheduleNext(); } } }); if (active == null) { scheduleNext(); } } protected synchronized void scheduleNext() { if ((active = tasks.poll()) != null) { executor.execute(active); } } }}&lt;pre&gt; The {@code Executor} implementations provided in this package implement {@link ExecutorService}, which is a more extensive interface. The {@link ThreadPoolExecutor} class provides an extensible thread pool implementation. The {@link Executors} class provides convenient factory methods for these Executors. &lt;p&gt;Memory consistency effects: Actions in a thread prior to submitting a {@code Runnable} object to an {@code Executor} &lt;a href=&quot;package-summary.htmlMemoryVisibility&quot;&gt;&lt;i&gt;happen-before&lt;i&gt;&lt;a&gt; its execution begins, perhaps in another thread." />
      <item value="Executor Service" />
      <item value="Executor" />
      <item value="get Row Id" />
      <item value="bean Dest" />
      <item value="parse Object" />
      <item value="promobj" />
      <item value="Req Cont Review" />
      <item value="get" />
      <item value="parameter Map" />
      <item value="to JSON String" />
      <item value="JSON" />
      <item value="String" />
      <item value="Request Body" />
      <item value="晚开始观看此书" />
      <item value="13336" />
      <item value="Engine Proc Inst" />
      <item value="engine Flow Service" />
      <item value="Clinton Begin Kazuki Shimizu" />
      <item value="statement Annotation Types" />
      <item value="The annotation type {@code java.lang.annotation.Repeatable} is used to indicate that the annotation type whose declaration it (meta-)annotates is &lt;em&gt;repeatable&lt;em&gt;. The value of {@code @Repeatable} indicates the &lt;em&gt;containing annotation type&lt;em&gt; for the repeatable annotation type." />
      <item value="Indicates the &lt;em&gt;containing annotation type&lt;em&gt; for the repeatable annotation type. @return the containing annotation type" />
      <item value="Repeatable" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="3694" />
        <entry key="ENGLISH" value="3695" />
        <entry key="ALBANIAN" value="3" />
        <entry key="ARABIC" value="3" />
        <entry key="IRISH" value="1" />
        <entry key="ICELANDIC" value="3" />
        <entry key="AFRIKAANS" value="2" />
        <entry key="DANISH" value="1" />
        <entry key="GERMAN" value="2" />
        <entry key="FRENCH" value="2" />
        <entry key="FILIPINO" value="2" />
        <entry key="HAITIAN_CREOLE" value="2" />
        <entry key="DUTCH" value="2" />
        <entry key="CATALAN" value="2" />
        <entry key="KANNADA" value="1" />
        <entry key="LATIN" value="11" />
        <entry key="LATVIAN" value="1" />
        <entry key="LUXEMBOURGISH" value="2" />
        <entry key="ROMANIAN" value="5" />
        <entry key="MALAGASY" value="1" />
        <entry key="MALTESE" value="2" />
        <entry key="MAORI" value="1" />
        <entry key="HMONG" value="1" />
        <entry key="NORWEGIAN" value="3" />
        <entry key="PORTUGUESE" value="7" />
        <entry key="JAPANESE" value="1" />
        <entry key="SWEDISH" value="2" />
        <entry key="SLOVENIAN" value="1" />
        <entry key="WELSH" value="2" />
        <entry key="UZBEK" value="2" />
        <entry key="SPANISH" value="6" />
        <entry key="HAWAIIAN" value="2" />
        <entry key="HUNGARIAN" value="1" />
        <entry key="ITALIAN" value="6" />
        <entry key="HINDI" value="4" />
        <entry key="INDONESIAN" value="4" />
        <entry key="JAVANESE" value="1" />
        <entry key="YORUBA" value="1" />
        <entry key="VIETNAMESE" value="4" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1659860808522" />
  </component>
</application>
<application>
  <component name="AppStorage">
    <histories>
      <item value="accept" />
      <item value="Jabber Client Thread" />
      <item value="Buffered Reader" />
      <item value="Method called by {@link com.fasterxml.jackson.core.JsonFactory} instance when creating parser given an {@link Reader}, when this decorator has been registered. @param ctxt IO context in use (provides access to declared encoding) NOTE: at this point context may not have all information initialized; specifically auto-detected encoding is only available once parsing starts, which may occur only after this method is called. @param r Original reader @return Reader to use; either passed in argument, or something that calls it (for example, a {@link FilterReader}) @throws IOException if construction of {@link Reader} fails" />
      <item value="Pushback Reader" />
      <item value="is Java Identifier Part" />
      <item value="Java Writer" />
      <item value="Filter Writer" />
      <item value="This class is the superclass of all classes that filter output streams. These streams sit on top of an already existing output stream (the &lt;i&gt;underlying&lt;i&gt; output stream) which it uses as its basic sink of data, but possibly transforming the data along the way or providing additional functionality. &lt;p&gt; The class &lt;code&gt;FilterOutputStream&lt;code&gt; itself simply overrides all methods of &lt;code&gt;OutputStream&lt;code&gt; with versions that pass all requests to the underlying output stream. Subclasses of &lt;code&gt;FilterOutputStream&lt;code&gt; may further override some of these methods as well as provide additional methods and fields." />
      <item value="Non Closing Output Stream" />
      <item value="Appendable" />
      <item value="is Underflow" />
      <item value="Expunge a stale entry by rehashing any possibly colliding entries lying between staleSlot and the next null slot. This also expunges any other stale entries encountered before the trailing null. See Knuth, Section 6.4 @param staleSlot index of slot known to have null key @return the index of the next null slot after staleSlot (all between staleSlot and this slot will have been checked for expunging)." />
      <item value="expunge Stale Entry" />
      <item value="impl Write" />
      <item value="Stream Decoder" />
      <item value="Win 32 Error Mode" />
      <item value="for Input Stream Reader" />
      <item value="remaining" />
      <item value="The object used to synchronize operations on this stream. For efficiency, a character-stream object may use an object other than itself to protect critical sections. A subclass should therefore use the object in this field rather than &lt;tt&gt;this&lt;tt&gt; or a synchronized method." />
      <item value="Mark Reinhold" />
      <item value="try Acquire Shared Nanos" />
      <item value="release" />
      <item value="Not quite a no-op; ensures volatile write semantics" />
      <item value="A thread-safe variant of {@link java.util.ArrayList} in which all mutative operations ({@code add}, {@code set}, and so on) are implemented by making a fresh copy of the underlying array. &lt;p&gt;This is ordinarily too costly, but may be &lt;em&gt;more&lt;em&gt; efficient than alternatives when traversal operations vastly outnumber mutations, and is useful when you cannot or don't want to synchronize traversals, yet need to preclude interference among concurrent threads. The &quot;snapshot&quot; style iterator method uses a reference to the state of the array at the point that the iterator was created. This array never changes during the lifetime of the iterator, so interference is impossible and the iterator is guaranteed not to throw {@code ConcurrentModificationException}. The iterator will not reflect additions, removals, or changes to the list since the iterator was created. Element-changing operations on iterators themselves ({@code remove}, {@code set}, and {@code add}) are not supported. These methods throw {@code UnsupportedOperationException}. &lt;p&gt;All elements are permitted, including {@code null}. &lt;p&gt;Memory consistency effects: As with other concurrent collections, actions in a thread prior to placing an object into a {@code CopyOnWriteArrayList} &lt;a href=&quot;package-summary.htmlMemoryVisibility&quot;&gt;&lt;i&gt;happen-before&lt;i&gt;&lt;a&gt; actions subsequent to the access or removal of that element from the {@code CopyOnWriteArrayList} in another thread. &lt;p&gt;This class is a member of the &lt;a href=&quot;{@docRoot}..technotesguidescollectionsindex.html&quot;&gt; Java Collections Framework&lt;a&gt;." />
      <item value="get Component Type" />
      <item value="Buffer" />
      <item value="Char Buffer" />
      <item value="Readable" />
      <item value="seek" />
      <item value="poiniter" />
      <item value="Random Access File Factory" />
      <item value="Factory" />
      <item value="read Unsigned Byte" />
      <item value="available" />
      <item value="ckage" />
      <item value="Test Eof" />
      <item value="Skip a leftover '\n', if necessary" />
      <item value="David Connelly" />
      <item value="Jonathan Payne" />
      <item value="The position within the pushback buffer from which the next byte will be read. When the buffer is empty, &lt;code&gt;pos&lt;code&gt; is equal to &lt;code&gt;buf.length&lt;code&gt;; when the buffer is full, &lt;code&gt;pos&lt;code&gt; is equal to zero." />
      <item value="unread" />
      <item value="Pushback Input Stream" />
      <item value="If a security manager exists and its &lt;code&gt;{@link java.lang.SecurityManagercheckWrite(java.lang.String)}&lt;code&gt; method denies write access to the file" />
      <item value="If an IO error occurred" />
      <item value="&lt;code&gt;true&lt;code&gt; if the named file does not exist and was successfully created; &lt;code&gt;false&lt;code&gt; if the named file already exists" />
      <item value="Atomically creates a new, empty file named by this abstract pathname if and only if a file with this name does not yet exist. The check for the existence of the file and the creation of the file if it does not exist are a single operation that is atomic with respect to all other filesystem activities that might affect the file. &lt;P&gt; Note: this method should &lt;i&gt;not&lt;i&gt; be used for file-locking, as the resulting protocol cannot be made to work reliably. The {@link java.nio.channels.FileLock FileLock} facility should be used instead. @return &lt;code&gt;true&lt;code&gt; if the named file does not exist and was successfully created; &lt;code&gt;false&lt;code&gt; if the named file already exists @throws IOException If an IO error occurred @throws SecurityException If a security manager exists and its &lt;code&gt;{@link java.lang.SecurityManagercheckWrite(java.lang.String)}&lt;code&gt; method denies write access to the file @since 1.2" />
      <item value="Ho Hum Exception" />
      <item value="Atomically creates a new, empty file named by this abstract pathname if and only if a file with this name does not yet exist. The check for the existence of the file and the creation of the file if it does not exist are a single operation that is atomic with respect to all other filesystem activities that might affect the file. &lt;P&gt; Note: this method should &lt;i&gt;not&lt;i&gt; be used for file-locking, as the resulting protocol cannot be made to work reliably. The {@link java.nio.channels.FileLock FileLock} facility should be used instead." />
      <item value="Creates the directory named by this abstract pathname." />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="60" />
        <entry key="ENGLISH" value="61" />
        <entry key="HMONG" value="1" />
        <entry key="HINDI" value="1" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1655556977798" />
  </component>
</application>